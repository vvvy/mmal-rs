/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MMAL_FALSE: u32 = 0;
pub const MMAL_TRUE: u32 = 1;
pub const MMAL_ENCODING_VARIANT_H264_DEFAULT: u32 = 0;
pub const MMAL_ENCODING_VARIANT_MP4A_DEFAULT: u32 = 0;
pub const MMAL_COLOR_SPACE_UNKNOWN: u32 = 0;
pub const MMAL_ES_FORMAT_FLAG_FRAMED: u32 = 1;
pub const MMAL_ES_FORMAT_FLAG_COL_FMTS_WIDTH_IS_COL_STRIDE: u32 = 2;
pub const MMAL_ENCODING_UNKNOWN: u32 = 0;
pub const MMAL_ENCODING_VARIANT_DEFAULT: u32 = 0;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_TYPE: u32 = 1;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_ENCODING: u32 = 2;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_BITRATE: u32 = 4;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_FLAGS: u32 = 8;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_EXTRADATA: u32 = 16;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_RESOLUTION: u32 = 256;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_CROPPING: u32 = 512;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_FRAME_RATE: u32 = 1024;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_ASPECT_RATIO: u32 = 2048;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_VIDEO_COLOR_SPACE: u32 = 4096;
pub const MMAL_ES_FORMAT_COMPARE_FLAG_ES_OTHER: u32 = 268435456;
pub const MMAL_BUFFER_HEADER_FLAG_EOS: u32 = 1;
pub const MMAL_BUFFER_HEADER_FLAG_FRAME_START: u32 = 2;
pub const MMAL_BUFFER_HEADER_FLAG_FRAME_END: u32 = 4;
pub const MMAL_BUFFER_HEADER_FLAG_FRAME: u32 = 6;
pub const MMAL_BUFFER_HEADER_FLAG_KEYFRAME: u32 = 8;
pub const MMAL_BUFFER_HEADER_FLAG_DISCONTINUITY: u32 = 16;
pub const MMAL_BUFFER_HEADER_FLAG_CONFIG: u32 = 32;
pub const MMAL_BUFFER_HEADER_FLAG_ENCRYPTED: u32 = 64;
pub const MMAL_BUFFER_HEADER_FLAG_CODECSIDEINFO: u32 = 128;
pub const MMAL_BUFFER_HEADER_FLAGS_SNAPSHOT: u32 = 256;
pub const MMAL_BUFFER_HEADER_FLAG_CORRUPTED: u32 = 512;
pub const MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED: u32 = 1024;
pub const MMAL_BUFFER_HEADER_FLAG_DECODEONLY: u32 = 2048;
pub const MMAL_BUFFER_HEADER_FLAG_NAL_END: u32 = 4096;
pub const MMAL_BUFFER_HEADER_FLAG_USER0: u32 = 268435456;
pub const MMAL_BUFFER_HEADER_FLAG_USER1: u32 = 536870912;
pub const MMAL_BUFFER_HEADER_FLAG_USER2: u32 = 1073741824;
pub const MMAL_BUFFER_HEADER_FLAG_USER3: u32 = 2147483648;
pub const MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START_BIT: u32 = 16;
pub const MMAL_BUFFER_HEADER_FLAG_FORMAT_SPECIFIC_START: u32 = 65536;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_INTERLACED: u32 = 65536;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_TOP_FIELD_FIRST: u32 = 131072;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_DISPLAY_EXTERNAL: u32 = 524288;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_PROTECTED: u32 = 1048576;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_SHIFT: u32 = 24;
pub const MMAL_BUFFER_HEADER_VIDEO_FLAG_COLUMN_LOG2_MASK: u32 = 251658240;
pub const MMAL_PARAMETER_GROUP_COMMON: u32 = 0;
pub const MMAL_PARAMETER_GROUP_CAMERA: u32 = 65536;
pub const MMAL_PARAMETER_GROUP_VIDEO: u32 = 131072;
pub const MMAL_PARAMETER_GROUP_AUDIO: u32 = 196608;
pub const MMAL_PARAMETER_GROUP_CLOCK: u32 = 262144;
pub const MMAL_PARAMETER_GROUP_MIRACAST: u32 = 327680;
pub const MMAL_PARAM_SEEK_FLAG_PRECISE: u32 = 1;
pub const MMAL_PARAM_SEEK_FLAG_FORWARD: u32 = 2;
pub const MMAL_MAX_IMAGEFX_PARAMETERS: u32 = 6;
pub const MMAL_PARAMETER_CAMERA_INFO_MAX_CAMERAS: u32 = 4;
pub const MMAL_PARAMETER_CAMERA_INFO_MAX_FLASHES: u32 = 2;
pub const MMAL_PARAMETER_CAMERA_INFO_MAX_STR_LEN: u32 = 16;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN: u32 = 32;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V2: u32 = 256;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V3: u32 = 256;
pub const MMAL_CAMERA_ANNOTATE_MAX_TEXT_LEN_V4: u32 = 256;
pub const MMAL_NUM_GAMMA_PTS: u32 = 33;
pub const MMAL_CLOCK_EVENT_INVALID: u32 = 0;
pub const MMAL_FIXED_16_16_ONE: u32 = 65536;
pub const MMAL_PORT_CAPABILITY_PASSTHROUGH: u32 = 1;
pub const MMAL_PORT_CAPABILITY_ALLOCATION: u32 = 2;
pub const MMAL_PORT_CAPABILITY_SUPPORTS_EVENT_FORMAT_CHANGE: u32 = 4;
pub const MMAL_VERSION_MAJOR: u32 = 0;
pub const MMAL_VERSION_MINOR: u32 = 1;
pub const MMAL_VERSION: u32 = 1;
pub const MMAL_COMPONENT_DEFAULT_CONTAINER_READER: &[u8; 17usize] = b"container_reader\0";
pub const MMAL_COMPONENT_DEFAULT_CONTAINER_WRITER: &[u8; 17usize] = b"container_writer\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_DECODER: &[u8; 20usize] = b"vc.ril.video_decode\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_ENCODER: &[u8; 20usize] = b"vc.ril.video_encode\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER: &[u8; 20usize] = b"vc.ril.video_render\0";
pub const MMAL_COMPONENT_DEFAULT_IMAGE_DECODER: &[u8; 20usize] = b"vc.ril.image_decode\0";
pub const MMAL_COMPONENT_DEFAULT_IMAGE_ENCODER: &[u8; 20usize] = b"vc.ril.image_encode\0";
pub const MMAL_COMPONENT_DEFAULT_CAMERA: &[u8; 14usize] = b"vc.ril.camera\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_CONVERTER: &[u8; 17usize] = b"vc.video_convert\0";
pub const MMAL_COMPONENT_DEFAULT_SPLITTER: &[u8; 12usize] = b"vc.splitter\0";
pub const MMAL_COMPONENT_DEFAULT_SCHEDULER: &[u8; 13usize] = b"vc.scheduler\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_INJECTER: &[u8; 16usize] = b"vc.video_inject\0";
pub const MMAL_COMPONENT_DEFAULT_VIDEO_SPLITTER: &[u8; 22usize] = b"vc.ril.video_splitter\0";
pub const MMAL_COMPONENT_DEFAULT_AUDIO_DECODER: &[u8; 5usize] = b"none\0";
pub const MMAL_COMPONENT_DEFAULT_AUDIO_RENDERER: &[u8; 20usize] = b"vc.ril.audio_render\0";
pub const MMAL_COMPONENT_DEFAULT_MIRACAST: &[u8; 12usize] = b"vc.miracast\0";
pub const MMAL_COMPONENT_DEFAULT_CLOCK: &[u8; 9usize] = b"vc.clock\0";
pub const MMAL_COMPONENT_DEFAULT_CAMERA_INFO: &[u8; 15usize] = b"vc.camera_info\0";
pub const MMAL_CONNECTION_FLAG_TUNNELLING: u32 = 1;
pub const MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT: u32 = 2;
pub const MMAL_CONNECTION_FLAG_ALLOCATION_ON_OUTPUT: u32 = 4;
pub const MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS: u32 = 8;
pub const MMAL_CONNECTION_FLAG_DIRECT: u32 = 16;
pub const MMAL_CONNECTION_FLAG_KEEP_PORT_FORMATS: u32 = 32;
pub const MMAL_DEV_VCHIQ_PATH: &[u8; 11usize] = b"/dev/vchiq\0";
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl ::std::fmt::Debug for __atomic_wide_counter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__atomic_wide_counter {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl ::std::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__pthread_cond_s {{ __wseq: {:?}, __g1_start: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __wseq , self . __g1_start , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals)
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
extern "C" {
    pub fn vcos_pthreads_logging_assert(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[doc = " Thread entry point. Returns a void* for consistency\n with pthreads."]
pub type VCOS_THREAD_ENTRY_FN_T = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub const VCOS_STATUS_T_VCOS_SUCCESS: VCOS_STATUS_T = 0;
pub const VCOS_STATUS_T_VCOS_EAGAIN: VCOS_STATUS_T = 1;
pub const VCOS_STATUS_T_VCOS_ENOENT: VCOS_STATUS_T = 2;
pub const VCOS_STATUS_T_VCOS_ENOSPC: VCOS_STATUS_T = 3;
pub const VCOS_STATUS_T_VCOS_EINVAL: VCOS_STATUS_T = 4;
pub const VCOS_STATUS_T_VCOS_EACCESS: VCOS_STATUS_T = 5;
pub const VCOS_STATUS_T_VCOS_ENOMEM: VCOS_STATUS_T = 6;
pub const VCOS_STATUS_T_VCOS_ENOSYS: VCOS_STATUS_T = 7;
pub const VCOS_STATUS_T_VCOS_EEXIST: VCOS_STATUS_T = 8;
pub const VCOS_STATUS_T_VCOS_ENXIO: VCOS_STATUS_T = 9;
pub const VCOS_STATUS_T_VCOS_EINTR: VCOS_STATUS_T = 10;
pub type VCOS_STATUS_T = ::std::os::raw::c_uint;
extern "C" {
    pub fn vcos_verify_bkpts_enabled() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vcos_verify_bkpts_enable(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vcos_abort();
}
extern "C" {
    #[doc = " Print out a backtrace, on supported platforms."]
    pub fn vcos_backtrace_self();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    const UNINIT: ::std::mem::MaybeUninit<sem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
impl ::std::fmt::Debug for sem_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "sem_t {{ union }}")
    }
}
pub type VCOS_SEMAPHORE_T = sem_t;
pub type VCOS_UNSIGNED = u32;
pub type VCOS_OPTION = u32;
pub type VCOS_ONCE_T = pthread_once_t;
pub type VCOS_MUTEX_T = pthread_mutex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_TIMER_T {
    #[doc = "< id of the timer thread"]
    pub thread: pthread_t,
    #[doc = "< lock protecting all other members of the struct"]
    pub lock: pthread_mutex_t,
    #[doc = "< cond. var. for informing the timer thread about changes"]
    pub settings_changed: pthread_cond_t,
    #[doc = "< non-zero if the timer thread is requested to quit"]
    pub quit: ::std::os::raw::c_int,
    #[doc = "< absolute time of next expiration, or 0 if disarmed"]
    pub expires: timespec,
    #[doc = "< the expiration routine provided by the user of the timer"]
    pub orig_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = "< the context for exp. routine provided by the user"]
    pub orig_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_TIMER_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_TIMER_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_TIMER_T>(),
        136usize,
        concat!("Size of: ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_TIMER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settings_changed) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(settings_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quit) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expires) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_expiration_routine) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_expiration_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_context) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_context)
        )
    );
}
impl ::std::fmt::Debug for VCOS_TIMER_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "VCOS_TIMER_T {{ thread: {:?}, lock: {:?}, settings_changed: {:?}, quit: {:?}, expires: {:?}, orig_expiration_routine: {:?}, orig_context: {:?} }}" , self . thread , self . lock , self . settings_changed , self . quit , self . expires , self . orig_expiration_routine , self . orig_context)
    }
}
#[doc = " Thread attribute structure. Don't use pthread_attr directly, as\n the calls can fail, and inits must match deletes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_ATTR_T {
    pub ta_stackaddr: *mut ::std::os::raw::c_void,
    pub ta_stacksz: VCOS_UNSIGNED,
    pub ta_priority: VCOS_UNSIGNED,
    pub ta_affinity: VCOS_UNSIGNED,
    pub ta_timeslice: VCOS_UNSIGNED,
    pub legacy: VCOS_UNSIGNED,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_ATTR_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_THREAD_ATTR_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_ATTR_T>(),
        32usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_ATTR_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ta_stackaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stackaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ta_stacksz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stacksz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ta_priority) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ta_affinity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_affinity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ta_timeslice) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_timeslice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).legacy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(legacy)
        )
    );
}
#[doc = " Called at thread exit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_EXIT_T {
    pub pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub cxt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_EXIT_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_THREAD_EXIT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_EXIT_T>(),
        16usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_EXIT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pfn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cxt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(cxt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_THREAD_T {
    #[doc = "< The thread itself"]
    pub thread: pthread_t,
    #[doc = "< The thread entry point"]
    pub entry: VCOS_THREAD_ENTRY_FN_T,
    #[doc = "< The argument to be passed to entry"]
    pub arg: *mut ::std::os::raw::c_void,
    #[doc = "< For support event groups and similar - a per thread semaphore"]
    pub suspend: VCOS_SEMAPHORE_T,
    pub task_timer: VCOS_TIMER_T,
    #[doc = "< non-zero if the task timer has already been created"]
    pub task_timer_created: ::std::os::raw::c_int,
    pub orig_task_timer_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_task_timer_context: *mut ::std::os::raw::c_void,
    pub legacy: VCOS_UNSIGNED,
    #[doc = "< Record the name of this thread, for diagnostics"]
    pub name: [::std::os::raw::c_char; 16usize],
    #[doc = "< Dummy thread created for non-vcos created threads"]
    pub dummy: VCOS_UNSIGNED,
    #[doc = " Callback invoked at thread exit time"]
    pub at_exit: [VCOS_THREAD_EXIT_T; 4usize],
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_THREAD_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_T>(),
        304usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suspend) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_timer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_timer_created) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer_created)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).orig_task_timer_expiration_routine) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_expiration_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_task_timer_context) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).legacy) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).at_exit) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(at_exit)
        )
    );
}
impl ::std::fmt::Debug for VCOS_THREAD_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "VCOS_THREAD_T {{ thread: {:?}, entry: {:?}, arg: {:?}, suspend: {:?}, task_timer: {:?}, task_timer_created: {:?}, orig_task_timer_expiration_routine: {:?}, orig_task_timer_context: {:?}, name: {:?}, at_exit: {:?} }}" , self . thread , self . entry , self . arg , self . suspend , self . task_timer , self . task_timer_created , self . orig_task_timer_expiration_routine , self . orig_task_timer_context , self . name , self . at_exit)
    }
}
#[doc = " \\file\n\n This provides event flags (as per Nucleus Event Groups) based on a\n mutex, a semaphore (per waiting thread) and a timer (per waiting\n thread).\n\n The data structure is a 32 bit unsigned int (the current set of\n flags) and a linked list of clients waiting to be 'satisfied'.\n\n The mutex merely locks access to the data structure. If a client\n calls vcos_event_flags_get() and the requested bits are not already\n present, it then sleeps on its per-thread semaphore after adding\n this semaphore to the queue waiting. It also sets up a timer.\n\n The per-thread semaphore and timer are actually stored in the\n thread context (joinable thread). In future it may become necessary\n to support non-VCOS threads by using thread local storage to\n create these objects and associate them with the thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_WAITER_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T {
    #[doc = "< Events currently set"]
    pub events: VCOS_UNSIGNED,
    #[doc = "< Serialize access"]
    pub lock: VCOS_MUTEX_T,
    pub waiters: VCOS_EVENT_FLAGS_T__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T__bindgen_ty_1 {
    #[doc = "< List of threads waiting"]
    pub head: *mut VCOS_EVENT_WAITER_T,
    #[doc = "< List of threads waiting"]
    pub tail: *mut VCOS_EVENT_WAITER_T,
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_EVENT_FLAGS_T__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_EVENT_FLAGS_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T>(),
        64usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waiters) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(waiters)
        )
    );
}
impl ::std::fmt::Debug for VCOS_EVENT_FLAGS_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "VCOS_EVENT_FLAGS_T {{ lock: {:?}, waiters: {:?} }}",
            self.lock, self.waiters
        )
    }
}
extern "C" {
    pub fn vcos_generic_event_flags_create(
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_event_flags_set(
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    );
}
extern "C" {
    pub fn vcos_generic_event_flags_delete(arg1: *mut VCOS_EVENT_FLAGS_T);
}
extern "C" {
    pub fn vcos_generic_event_flags_get(
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_HEADER_TAG {
    pub owner: VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    pub next: *mut VCOS_BLOCKPOOL_HEADER_TAG,
    pub subpool: *mut VCOS_BLOCKPOOL_SUBPOOL_TAG,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subpool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(subpool)
        )
    );
}
impl ::std::fmt::Debug for VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_BLOCKPOOL_HEADER_TAG> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG),
            "::",
            stringify!(owner)
        )
    );
}
impl ::std::fmt::Debug for VCOS_BLOCKPOOL_HEADER_TAG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "VCOS_BLOCKPOOL_HEADER_TAG {{ owner: {:?} }}", self.owner)
    }
}
pub type VCOS_BLOCKPOOL_HEADER_T = VCOS_BLOCKPOOL_HEADER_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_BLOCKPOOL_SUBPOOL_TAG {
    #[doc = " VCOS_BLOCKPOOL_SUBPOOL_MAGIC"]
    pub magic: u32,
    pub free_list: *mut VCOS_BLOCKPOOL_HEADER_T,
    pub mem: *mut ::std::os::raw::c_void,
    pub start: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
    #[doc = " The number of blocks in this sub-pool"]
    pub num_blocks: VCOS_UNSIGNED,
    #[doc = " Current number of available blocks in this sub-pool"]
    pub available_blocks: VCOS_UNSIGNED,
    #[doc = " Pointers to the pool that owns this sub-pool"]
    pub owner: *mut VCOS_BLOCKPOOL_TAG,
    #[doc = " Define properties such as memory ownership"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_SUBPOOL_TAG() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_BLOCKPOOL_SUBPOOL_TAG> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        64usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_blocks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available_blocks) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(available_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
}
pub type VCOS_BLOCKPOOL_SUBPOOL_T = VCOS_BLOCKPOOL_SUBPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_TAG {
    #[doc = " VCOS_BLOCKPOOL_MAGIC"]
    pub magic: u32,
    #[doc = " Thread safety for Alloc, Free, Delete, Stats"]
    pub mutex: VCOS_MUTEX_T,
    #[doc = " Alignment of block data pointers"]
    pub align: VCOS_UNSIGNED,
    #[doc = " Flags for future use e.g. cache options"]
    pub flags: VCOS_UNSIGNED,
    #[doc = " The size of the block data"]
    pub block_data_size: usize,
    #[doc = " Block size inc overheads"]
    pub block_size: usize,
    #[doc = " Name for debugging"]
    pub name: *const ::std::os::raw::c_char,
    pub num_subpools: VCOS_UNSIGNED,
    #[doc = " Number of blocks in each dynamically allocated subpool"]
    pub num_extension_blocks: VCOS_UNSIGNED,
    #[doc = " Array of subpools. Subpool zero is is not deleted until the pool is\n destroed. If the index of the pool is < num_subpools and\n subpool[index.mem] is null then the subpool entry is valid but\n \"not currently allocated\""]
    pub subpools: [VCOS_BLOCKPOOL_SUBPOOL_T; 8usize],
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_TAG() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_BLOCKPOOL_TAG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_TAG>(),
        600usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_TAG>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).align) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_data_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_subpools) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_subpools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_extension_blocks) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_extension_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subpools) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(subpools)
        )
    );
}
impl ::std::fmt::Debug for VCOS_BLOCKPOOL_TAG {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "VCOS_BLOCKPOOL_TAG {{ mutex: {:?}, name: {:?}, subpools: {:?} }}",
            self.mutex, self.name, self.subpools
        )
    }
}
pub type VCOS_BLOCKPOOL_T = VCOS_BLOCKPOOL_TAG;
extern "C" {
    pub fn vcos_generic_blockpool_init(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_blockpool_create_on_heap(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_blockpool_extend(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_blockpool_alloc(pool: *mut VCOS_BLOCKPOOL_T)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_blockpool_calloc(
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_blockpool_free(block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vcos_generic_blockpool_available_count(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED;
}
extern "C" {
    pub fn vcos_generic_blockpool_used_count(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED;
}
extern "C" {
    pub fn vcos_generic_blockpool_delete(pool: *mut VCOS_BLOCKPOOL_T);
}
extern "C" {
    pub fn vcos_generic_blockpool_elem_to_handle(block: *mut ::std::os::raw::c_void) -> u32;
}
extern "C" {
    pub fn vcos_generic_blockpool_elem_from_handle(
        pool: *mut VCOS_BLOCKPOOL_T,
        handle: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_blockpool_is_valid_elem(
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " \\file\n\n Create the vcos malloc API from a regular system malloc/free library.\n\n The API lets callers specify an alignment.\n\n Under VideoCore this is not needed, as we can simply use the rtos_malloc routines.\n But on host platforms that won't be the case.\n"]
    pub fn vcos_generic_mem_alloc(
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_mem_calloc(
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_generic_mem_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn vcos_generic_mem_alloc_aligned(
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Convert errno values into the values recognized by vcos"]
    pub fn vcos_pthreads_map_error(error: ::std::os::raw::c_int) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_pthreads_map_errno() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Register a function to be called when the current thread exits."]
    pub fn vcos_thread_at_exit(
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Threads\n"]
    pub fn vcos_dummy_thread_create() -> *mut VCOS_THREAD_T;
}
extern "C" {
    pub fn vcos_getmicrosecs64_internal() -> u64;
}
extern "C" {
    #[doc = " Timers\n"]
    pub fn vcos_pthreads_timer_create(
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_pthreads_timer_set(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED);
}
extern "C" {
    pub fn vcos_pthreads_timer_cancel(timer: *mut VCOS_TIMER_T);
}
extern "C" {
    pub fn vcos_pthreads_timer_reset(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED);
}
extern "C" {
    pub fn vcos_pthreads_timer_delete(timer: *mut VCOS_TIMER_T);
}
#[doc = " \\file\n\n Reentrant Mutexes from regular ones.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_REENTRANT_MUTEX_T {
    pub mutex: VCOS_MUTEX_T,
    pub owner: *mut VCOS_THREAD_T,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VCOS_REENTRANT_MUTEX_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_REENTRANT_MUTEX_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_REENTRANT_MUTEX_T>(),
        56usize,
        concat!("Size of: ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_REENTRANT_MUTEX_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(count)
        )
    );
}
impl ::std::fmt::Debug for VCOS_REENTRANT_MUTEX_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "VCOS_REENTRANT_MUTEX_T {{ mutex: {:?}, owner: {:?}, count: {:?} }}",
            self.mutex, self.owner, self.count
        )
    }
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_create(
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_delete(m: *mut VCOS_REENTRANT_MUTEX_T);
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_lock(m: *mut VCOS_REENTRANT_MUTEX_T);
}
extern "C" {
    pub fn vcos_generic_reentrant_mutex_unlock(m: *mut VCOS_REENTRANT_MUTEX_T);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_T {
    #[doc = "< There are 'n' named semaphores per 1 actual semaphore"]
    pub actual: *mut VCOS_NAMED_SEMAPHORE_IMPL_T,
    #[doc = "< Pointer to actual underlying semaphore"]
    pub sem: *mut VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_VCOS_NAMED_SEMAPHORE_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_NAMED_SEMAPHORE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_NAMED_SEMAPHORE_T>(),
        16usize,
        concat!("Size of: ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_NAMED_SEMAPHORE_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(actual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(sem)
        )
    );
}
extern "C" {
    pub fn vcos_generic_named_semaphore_create(
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " \\brief Delete a semaphore, releasing any resources consumed by it.\n\n @param sem Semaphore to wait on"]
    pub fn vcos_named_semaphore_delete(sem: *mut VCOS_NAMED_SEMAPHORE_T);
}
extern "C" {
    #[doc = " vcos initialization. Call this function before using other vcos functions.\n Calls can be nested within the same process; they are reference counted so\n that only a call from uninitialized state has any effect.\n @note On platforms/toolchains that support it, gcc's constructor attribute or\n       similar is used to invoke this function before main() or equivalent.\n @return Status of initialisation."]
    pub fn vcos_init() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " vcos deinitialization. Call this function when vcos is no longer required,\n in order to free resources.\n Calls can be nested within the same process; they are reference counted so\n that only a call that decrements the reference count to 0 has any effect.\n @note On platforms/toolchains that support it, gcc's destructor attribute or\n       similar is used to invoke this function after exit() or equivalent.\n @return Status of initialisation."]
    pub fn vcos_deinit();
}
extern "C" {
    #[doc = " Acquire global lock. This must be available independent of vcos_init()/vcos_deinit()."]
    pub fn vcos_global_lock();
}
extern "C" {
    #[doc = " Release global lock. This must be available independent of vcos_init()/vcos_deinit()."]
    pub fn vcos_global_unlock();
}
extern "C" {
    #[doc = " Pass in the argv/argc arguments passed to main()"]
    pub fn vcos_set_args(argc: ::std::os::raw::c_int, argv: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Return argc."]
    pub fn vcos_get_argc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return argv."]
    pub fn vcos_get_argv() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Platform-specific initialisation.\n VCOS internal function, not part of public API, do not call from outside\n vcos. vcos_init()/vcos_deinit() reference count calls, so this function is\n only called from an uninitialized state, i.e. there will not be two\n consecutive calls to vcos_platform_init() without an intervening call to\n vcos_platform_deinit().\n This function is called with vcos_global_lock held.\n @return Status of initialisation."]
    pub fn vcos_platform_init() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Platform-specific de-initialisation.\n VCOS internal function, not part of public API, do not call from outside\n vcos.\n See vcos_platform_init() re reference counting.\n This function is called with vcos_global_lock held."]
    pub fn vcos_platform_deinit();
}
extern "C" {
    #[doc = " Report whether or not we have an RTOS at all, and hence the ability to\n create threads."]
    pub fn vcos_have_rtos() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a thread. It must be cleaned up by calling vcos_thread_join().\n\n @param thread   Filled in on return with thread\n @param name     A name for the thread. May be the empty string.\n @param attrs    Attributes; default attributes will be used if this is NULL.\n @param entry    Entry point.\n @param arg      Argument passed to the entry point."]
    pub fn vcos_thread_create(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Exit the thread from within the thread function itself.\n Resources must still be cleaned up via a call to thread_join().\n\n The thread can also be terminated by simply exiting the thread function.\n\n @param data Data passed to thread_join. May be NULL."]
    pub fn vcos_thread_exit(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Wait for a thread to terminate and then clean up its resources.\n\n @param thread Thread to wait for\n @param pData  Updated to point at data provided in vcos_thread_exit or exit\n code of thread function."]
    pub fn vcos_thread_join(thread: *mut VCOS_THREAD_T, pData: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " \\brief Create a thread using an API similar to the one \"traditionally\"\n used under Nucleus.\n\n This creates a thread which must be cleaned up by calling vcos_thread_join().\n The thread cannot be simply terminated (as in Nucleus and ThreadX) as thread\n termination is not universally supported.\n\n @param thread       Filled in with thread instance\n @param name         An optional name for the thread. NULL or \"\" may be used (but\n                     a name will aid in debugging).\n @param entry        Entry point\n @param arg          A single argument passed to the entry point function\n @param stack        Pointer to stack address\n @param stacksz      Size of stack in bytes\n @param priaff       Priority of task, between VCOS_PRI_LOW and VCOS_PRI_HIGH, ORed with the CPU affinity\n @param autostart    If non-zero the thread will start immediately.\n @param timeslice    Timeslice (system ticks) for this thread.\n\n @sa vcos_thread_terminate vcos_thread_delete"]
    pub fn vcos_thread_create_classic(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Return the name of the given thread."]
    pub fn vcos_thread_get_name(thread: *const VCOS_THREAD_T) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vcos_kmalloc(
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_kcalloc(
        num: VCOS_UNSIGNED,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcos_kfree(ptr: *mut ::std::os::raw::c_void);
}
pub type va_list = __builtin_va_list;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_UNINITIALIZED: VCOS_LOG_LEVEL_T = 0;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_NEVER: VCOS_LOG_LEVEL_T = 1;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_ERROR: VCOS_LOG_LEVEL_T = 2;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_WARN: VCOS_LOG_LEVEL_T = 3;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_INFO: VCOS_LOG_LEVEL_T = 4;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_TRACE: VCOS_LOG_LEVEL_T = 5;
#[doc = " Logging levels"]
pub type VCOS_LOG_LEVEL_T = ::std::os::raw::c_uint;
#[doc = " A registered logging category."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T {
    #[doc = "< Which levels are enabled for this category"]
    pub level: VCOS_LOG_LEVEL_T,
    #[doc = "< Name for this category."]
    pub name: *const ::std::os::raw::c_char,
    pub next: *mut VCOS_LOG_CAT_T,
    pub flags: VCOS_LOG_CAT_T__bindgen_ty_1,
    pub refcount: ::std::os::raw::c_uint,
    #[doc = "< platform specific data"]
    pub platform_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
}
impl VCOS_LOG_CAT_T__bindgen_ty_1 {
    #[inline]
    pub fn want_prefix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_prefix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_prefix: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_prefix: u32 = unsafe { ::std::mem::transmute(want_prefix) };
            want_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_LOG_CAT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T>(),
        40usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).platform_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(platform_data)
        )
    );
}
pub type VCOS_VLOG_IMPL_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    #[doc = " Convert a VCOS_LOG_LEVEL_T into a printable string.\n The platform needs to implement this function."]
    pub fn vcos_log_level_to_string(level: VCOS_LOG_LEVEL_T) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a string into a VCOS_LOG_LEVEL_T\n The platform needs to implement this function."]
    pub fn vcos_string_to_log_level(
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " Log a message. Basic API. Normal code should not use this.\n The platform needs to implement this function."]
    pub fn vcos_log_impl(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Log a message using a varargs parameter list. Normal code should\n not use this."]
    pub fn vcos_vlog_impl(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Set the function which does the actual logging output.\n  Passing in NULL causes the default logging function to be\n  used."]
    pub fn vcos_set_vlog_impl(vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T);
}
extern "C" {
    #[doc = " The default logging function, which is provided by each\n platform."]
    pub fn vcos_vlog_default_impl(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn vcos_logging_init();
}
extern "C" {
    #[doc = " Register a logging category.\n\n @param name the name of this category.\n @param category the category to register."]
    pub fn vcos_log_register(name: *const ::std::os::raw::c_char, category: *mut VCOS_LOG_CAT_T);
}
extern "C" {
    #[doc = " Unregister a logging category."]
    pub fn vcos_log_unregister(category: *mut VCOS_LOG_CAT_T);
}
extern "C" {
    #[doc = " Return a default logging category, for people too lazy to create their own.\n\n Using the default category will be slow (there's an extra function\n call overhead). Don't do this in normal code."]
    pub fn vcos_log_get_default_category() -> *const VCOS_LOG_CAT_T;
}
extern "C" {
    pub fn vcos_set_log_options(opt: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the logging levels for many categories at once.\n\n Set lots of categorys from a string cat:lev,cat:lev This can\n be used at startup time to set a bunch of category levels from\n a single string.  Used with C(vcos_logging_level)"]
    pub fn vcos_log_set_level_all(levels: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn vcos_log_dump_mem_impl(
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: usize,
    );
}
pub type VCOS_CMD_T = VCOS_CMD_S;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_PARAM_T {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
    pub argv_orig: *mut *mut ::std::os::raw::c_char,
    pub cmd_entry: *mut VCOS_CMD_T,
    pub cmd_parent_entry: *mut VCOS_CMD_T,
    pub use_log: ::std::os::raw::c_int,
    pub result_size: usize,
    pub result_ptr: *mut ::std::os::raw::c_char,
    pub result_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_PARAM_T() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_CMD_PARAM_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_PARAM_T>(),
        72usize,
        concat!("Size of: ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_PARAM_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).argv_orig) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv_orig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_parent_entry) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_parent_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_log) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(use_log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_ptr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_buf)
        )
    );
}
pub type VCOS_CMD_FUNC_T =
    ::std::option::Option<unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_S {
    pub name: *const ::std::os::raw::c_char,
    pub args: *const ::std::os::raw::c_char,
    pub cmd_fn: VCOS_CMD_FUNC_T,
    pub sub_cmd_entry: *mut VCOS_CMD_T,
    pub descr: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_S() {
    const UNINIT: ::std::mem::MaybeUninit<VCOS_CMD_S> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_S>(),
        40usize,
        concat!("Size of: ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_S>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(cmd_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_cmd_entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(sub_cmd_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(descr)
        )
    );
}
extern "C" {
    pub fn vcos_cmd_error(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vcos_cmd_printf(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vcos_cmd_vprintf(
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn vcos_cmd_always_log_output(log_category: *mut VCOS_LOG_CAT_T);
}
extern "C" {
    pub fn vcos_cmd_usage(param: *mut VCOS_CMD_PARAM_T);
}
extern "C" {
    pub fn vcos_cmd_register(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_cmd_register_multiple(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_cmd_execute(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: usize,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_cmd_shutdown();
}
extern "C" {
    pub fn vcos_log_assert_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_log_set_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_log_status_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_log_test_cmd(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T;
}
extern "C" {
    pub fn vcos_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vcos_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like vsnprintf, except it places the output at the specified offset.\n Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.\n Returns the string length before/without truncation."]
    pub fn vcos_safe_vsprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        offset: usize,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> usize;
}
extern "C" {
    #[doc = " Like snprintf, except it places the output at the specified offset.\n Output is truncated to fit in buflen bytes, and is guaranteed to be NUL-terminated.\n Returns the string length before/without truncation."]
    pub fn vcos_safe_sprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        offset: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> usize;
}
extern "C" {
    #[doc = " Copies string src to dst at the specified offset.\n Output is truncated to fit in dstlen bytes, i.e. the string is at most\n (buflen - 1) characters long. Unlike strncpy, exactly one NUL is written\n to dst, which is always NUL-terminated.\n Returns the string length before/without truncation."]
    pub fn vcos_safe_strcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: usize,
        offset: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Initialize thread attribute struct. This call does not allocate memory,\n and so cannot fail.\n"]
    pub fn vcos_thread_attr_init(attrs: *mut VCOS_THREAD_ATTR_T);
}
extern "C" {
    #[doc = " Perform timer subsystem initialization. This function is not needed\n on non-Windows platforms but is still present so that it can be\n called. On Windows it is needed because vcos_init() gets called\n from DLL initialization where it is not possible to create a\n time queue (deadlock occurs if you try).\n\n @return VCOS_SUCCESS on success. VCOS_EEXIST if this has already been called\n once. VCOS_ENOMEM if resource allocation failed."]
    pub fn vcos_timer_init() -> VCOS_STATUS_T;
}
extern "C" {
    #[doc = " \\file vcos_once.h\n\n Ensure something is called only once.\n\n Initialize once_control to VCOS_ONCE_INIT. The first\n time this is called, the init_routine will be called. Thereafter\n it won't.\n\n \\sa pthread_once()\n"]
    pub fn vcos_once(
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T;
}
pub type MMAL_BOOL_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CORE_STATISTICS_T {
    #[doc = "< Total buffer count on this port"]
    pub buffer_count: u32,
    #[doc = "< Time (us) of first buffer seen on this port"]
    pub first_buffer_time: u32,
    #[doc = "< Time (us) of most recently buffer on this port"]
    pub last_buffer_time: u32,
    #[doc = "< Max delay (us) between buffers, ignoring first few frames"]
    pub max_delay: u32,
}
#[test]
fn bindgen_test_layout_MMAL_CORE_STATISTICS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CORE_STATISTICS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CORE_STATISTICS_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CORE_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CORE_STATISTICS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_CORE_STATISTICS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_buffer_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(first_buffer_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_buffer_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(last_buffer_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_delay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_STATISTICS_T),
            "::",
            stringify!(max_delay)
        )
    );
}
#[doc = " Statistics collected by the core on all ports, if enabled in the build."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CORE_PORT_STATISTICS_T {
    pub rx: MMAL_CORE_STATISTICS_T,
    pub tx: MMAL_CORE_STATISTICS_T,
}
#[test]
fn bindgen_test_layout_MMAL_CORE_PORT_STATISTICS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CORE_PORT_STATISTICS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CORE_PORT_STATISTICS_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_CORE_PORT_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CORE_PORT_STATISTICS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_CORE_PORT_STATISTICS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_PORT_STATISTICS_T),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CORE_PORT_STATISTICS_T),
            "::",
            stringify!(tx)
        )
    );
}
#[doc = " Unsigned 16.16 fixed point value, also known as Q16.16"]
pub type MMAL_FIXED_16_16_T = u32;
pub mod MMAL_STATUS_T {
    #[doc = " Status return codes from the API.\n\n \\internal Please try to keep this similar to the standard POSIX codes\n rather than making up new ones!"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Success"]
    pub const MMAL_SUCCESS: Type = 0;
    #[doc = "< Out of memory"]
    pub const MMAL_ENOMEM: Type = 1;
    #[doc = "< Out of resources (other than memory)"]
    pub const MMAL_ENOSPC: Type = 2;
    #[doc = "< Argument is invalid"]
    pub const MMAL_EINVAL: Type = 3;
    #[doc = "< Function not implemented"]
    pub const MMAL_ENOSYS: Type = 4;
    #[doc = "< No such file or directory"]
    pub const MMAL_ENOENT: Type = 5;
    #[doc = "< No such device or address"]
    pub const MMAL_ENXIO: Type = 6;
    #[doc = "< I/O error"]
    pub const MMAL_EIO: Type = 7;
    #[doc = "< Illegal seek"]
    pub const MMAL_ESPIPE: Type = 8;
    #[doc = "< Data is corrupt \\attention FIXME: not POSIX"]
    pub const MMAL_ECORRUPT: Type = 9;
    #[doc = "< Component is not ready \\attention FIXME: not POSIX"]
    pub const MMAL_ENOTREADY: Type = 10;
    #[doc = "< Component is not configured \\attention FIXME: not POSIX"]
    pub const MMAL_ECONFIG: Type = 11;
    #[doc = "< Port is already connected"]
    pub const MMAL_EISCONN: Type = 12;
    #[doc = "< Port is disconnected"]
    pub const MMAL_ENOTCONN: Type = 13;
    #[doc = "< Resource temporarily unavailable. Try again later"]
    pub const MMAL_EAGAIN: Type = 14;
    #[doc = "< Bad address"]
    pub const MMAL_EFAULT: Type = 15;
    #[doc = "< Force to 32 bit"]
    pub const MMAL_STATUS_MAX: Type = 2147483647;
}
#[doc = " Describes a rectangle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_RECT_T {
    #[doc = "< x coordinate (from left)"]
    pub x: i32,
    #[doc = "< y coordinate (from top)"]
    pub y: i32,
    #[doc = "< width"]
    pub width: i32,
    #[doc = "< height"]
    pub height: i32,
}
#[test]
fn bindgen_test_layout_MMAL_RECT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_RECT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_RECT_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_RECT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_RECT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_RECT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RECT_T),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Describes a rational number"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_RATIONAL_T {
    #[doc = "< Numerator"]
    pub num: i32,
    #[doc = "< Denominator"]
    pub den: i32,
}
#[test]
fn bindgen_test_layout_MMAL_RATIONAL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_RATIONAL_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_RATIONAL_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_RATIONAL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_RATIONAL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_RATIONAL_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RATIONAL_T),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).den) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_RATIONAL_T),
            "::",
            stringify!(den)
        )
    );
}
#[doc = " Four Character Code type"]
pub type MMAL_FOURCC_T = u32;
#[doc = "< Unknown elementary stream type"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_UNKNOWN: MMAL_ES_TYPE_T = 0;
#[doc = "< Elementary stream of control commands"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_CONTROL: MMAL_ES_TYPE_T = 1;
#[doc = "< Audio elementary stream"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_AUDIO: MMAL_ES_TYPE_T = 2;
#[doc = "< Video elementary stream"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_VIDEO: MMAL_ES_TYPE_T = 3;
#[doc = "< Sub-picture elementary stream (e.g. subtitles, overlays)"]
pub const MMAL_ES_TYPE_T_MMAL_ES_TYPE_SUBPICTURE: MMAL_ES_TYPE_T = 4;
#[doc = " Enumeration of the different types of elementary streams.\n This divides elementary streams into 4 big categories, plus an invalid type."]
pub type MMAL_ES_TYPE_T = ::std::os::raw::c_uint;
#[doc = " Definition of a video format.\n This describes the properties specific to a video stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VIDEO_FORMAT_T {
    #[doc = "< Width of frame in pixels"]
    pub width: u32,
    #[doc = "< Height of frame in rows of pixels"]
    pub height: u32,
    #[doc = "< Visible region of the frame"]
    pub crop: MMAL_RECT_T,
    #[doc = "< Frame rate"]
    pub frame_rate: MMAL_RATIONAL_T,
    #[doc = "< Pixel aspect ratio"]
    pub par: MMAL_RATIONAL_T,
    #[doc = "< FourCC specifying the color space of the\n video stream. See the \\ref MmalColorSpace\n \"pre-defined color spaces\" for some examples."]
    pub color_space: MMAL_FOURCC_T,
}
#[test]
fn bindgen_test_layout_MMAL_VIDEO_FORMAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VIDEO_FORMAT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VIDEO_FORMAT_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_VIDEO_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VIDEO_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VIDEO_FORMAT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(crop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).par) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(par)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_space) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VIDEO_FORMAT_T),
            "::",
            stringify!(color_space)
        )
    );
}
#[doc = " Definition of an audio format.\n This describes the properties specific to an audio stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_AUDIO_FORMAT_T {
    #[doc = "< Number of audio channels"]
    pub channels: u32,
    #[doc = "< Sample rate"]
    pub sample_rate: u32,
    #[doc = "< Bits per sample"]
    pub bits_per_sample: u32,
    #[doc = "< Size of a block of data"]
    pub block_align: u32,
}
#[test]
fn bindgen_test_layout_MMAL_AUDIO_FORMAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_AUDIO_FORMAT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_AUDIO_FORMAT_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_AUDIO_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_AUDIO_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_AUDIO_FORMAT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(bits_per_sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_align) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_AUDIO_FORMAT_T),
            "::",
            stringify!(block_align)
        )
    );
}
#[doc = " Definition of a subpicture format.\n This describes the properties specific to a subpicture stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_SUBPICTURE_FORMAT_T {
    #[doc = "< Width offset to the start of the subpicture"]
    pub x_offset: u32,
    #[doc = "< Height offset to the start of the subpicture"]
    pub y_offset: u32,
}
#[test]
fn bindgen_test_layout_MMAL_SUBPICTURE_FORMAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_SUBPICTURE_FORMAT_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_SUBPICTURE_FORMAT_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_SUBPICTURE_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_SUBPICTURE_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_SUBPICTURE_FORMAT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_SUBPICTURE_FORMAT_T),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_SUBPICTURE_FORMAT_T),
            "::",
            stringify!(y_offset)
        )
    );
}
#[doc = " Definition of the type specific format.\n This describes the type specific information of the elementary stream."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMAL_ES_SPECIFIC_FORMAT_T {
    #[doc = "< Audio specific information"]
    pub audio: MMAL_AUDIO_FORMAT_T,
    #[doc = "< Video specific information"]
    pub video: MMAL_VIDEO_FORMAT_T,
    #[doc = "< Subpicture specific information"]
    pub subpicture: MMAL_SUBPICTURE_FORMAT_T,
}
#[test]
fn bindgen_test_layout_MMAL_ES_SPECIFIC_FORMAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_ES_SPECIFIC_FORMAT_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_ES_SPECIFIC_FORMAT_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_ES_SPECIFIC_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_ES_SPECIFIC_FORMAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_ES_SPECIFIC_FORMAT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_SPECIFIC_FORMAT_T),
            "::",
            stringify!(audio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_SPECIFIC_FORMAT_T),
            "::",
            stringify!(video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subpicture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_SPECIFIC_FORMAT_T),
            "::",
            stringify!(subpicture)
        )
    );
}
impl ::std::fmt::Debug for MMAL_ES_SPECIFIC_FORMAT_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "MMAL_ES_SPECIFIC_FORMAT_T {{ union }}")
    }
}
#[doc = " Definition of an elementary stream format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_ES_FORMAT_T {
    #[doc = "< Type of the elementary stream"]
    pub type_: MMAL_ES_TYPE_T,
    #[doc = "< FourCC specifying the encoding of the elementary stream.\n See the \\ref MmalEncodings \"pre-defined encodings\" for some\n examples."]
    pub encoding: MMAL_FOURCC_T,
    #[doc = "< FourCC specifying the specific encoding variant of\n the elementary stream. See the \\ref MmalEncodingVariants\n \"pre-defined encoding variants\" for some examples."]
    pub encoding_variant: MMAL_FOURCC_T,
    #[doc = "< Type specific information for the elementary stream"]
    pub es: *mut MMAL_ES_SPECIFIC_FORMAT_T,
    #[doc = "< Bitrate in bits per second"]
    pub bitrate: u32,
    #[doc = "< Flags describing properties of the elementary stream.\n See \\ref elementarystreamflags \"Elementary stream flags\"."]
    pub flags: u32,
    #[doc = "< Size of the codec specific data"]
    pub extradata_size: u32,
    #[doc = "< Codec specific data"]
    pub extradata: *mut u8,
}
#[test]
fn bindgen_test_layout_MMAL_ES_FORMAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_ES_FORMAT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_ES_FORMAT_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_ES_FORMAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_ES_FORMAT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_ES_FORMAT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding_variant) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(encoding_variant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).es) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extradata_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extradata) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_ES_FORMAT_T),
            "::",
            stringify!(extradata)
        )
    );
}
extern "C" {
    #[doc = " Allocate and initialise a \\ref MMAL_ES_FORMAT_T structure.\n\n @return a \\ref MMAL_ES_FORMAT_T structure"]
    pub fn mmal_format_alloc() -> *mut MMAL_ES_FORMAT_T;
}
extern "C" {
    #[doc = " Free a \\ref MMAL_ES_FORMAT_T structure allocated by \\ref mmal_format_alloc.\n\n @param format the \\ref MMAL_ES_FORMAT_T structure to free"]
    pub fn mmal_format_free(format: *mut MMAL_ES_FORMAT_T);
}
extern "C" {
    #[doc = " Allocate the extradata buffer in \\ref MMAL_ES_FORMAT_T.\n This buffer will be freed automatically when the format is destroyed or\n another allocation is done.\n\n @param format format structure for which the extradata buffer will be allocated\n @param size size of the extradata buffer to allocate\n @return MMAL_SUCCESS on success"]
    pub fn mmal_format_extradata_alloc(
        format: *mut MMAL_ES_FORMAT_T,
        size: ::std::os::raw::c_uint,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Shallow copy a format structure.\n It is worth noting that the extradata buffer will not be copied in the new format.\n\n @param format_dest destination \\ref MMAL_ES_FORMAT_T for the copy\n @param format_src source \\ref MMAL_ES_FORMAT_T for the copy"]
    pub fn mmal_format_copy(format_dest: *mut MMAL_ES_FORMAT_T, format_src: *mut MMAL_ES_FORMAT_T);
}
extern "C" {
    #[doc = " Fully copy a format structure, including the extradata buffer.\n\n @param format_dest destination \\ref MMAL_ES_FORMAT_T for the copy\n @param format_src source \\ref MMAL_ES_FORMAT_T for the copy\n @return MMAL_SUCCESS on success"]
    pub fn mmal_format_full_copy(
        format_dest: *mut MMAL_ES_FORMAT_T,
        format_src: *mut MMAL_ES_FORMAT_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Compare 2 format structures and returns a set of flags describing the differences.\n The result will be zero if the structures are the same, or a combination of\n one or more of the \\ref comparisonflags \"Comparison flags\" if different.\n\n @param format_1 first \\ref MMAL_ES_FORMAT_T to compare\n @param format_2 second \\ref MMAL_ES_FORMAT_T to compare\n @return set of flags describing the differences"]
    pub fn mmal_format_compare(
        format_1: *mut MMAL_ES_FORMAT_T,
        format_2: *mut MMAL_ES_FORMAT_T,
    ) -> u32;
}
#[doc = " Specific data associated with video frames"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T {
    #[doc = "< Number of planes composing the video frame"]
    pub planes: u32,
    #[doc = "< Offsets to the different planes. These must point within the\npayload buffer"]
    pub offset: [u32; 4usize],
    #[doc = "< Pitch (size in bytes of a line of a plane) of the different\nplanes"]
    pub pitch: [u32; 4usize],
    #[doc = "< Flags describing video specific properties of a buffer header\n(see \\ref videobufferheaderflags \"Video buffer header flags\")"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Type specific data that's associated with a payload buffer"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {
    #[doc = " Specific data associated with video frames"]
    pub video: MMAL_BUFFER_HEADER_VIDEO_SPECIFIC_T,
}
#[test]
fn bindgen_test_layout_MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T),
            "::",
            stringify!(video)
        )
    );
}
impl ::std::fmt::Debug for MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T {{ union }}")
    }
}
#[doc = " Definition of the buffer header structure.\n A buffer header does not directly carry the data to be passed to a component but instead\n it references the actual data using a pointer (and an associated length).\n It also contains an internal area which can be used to store command to be associated\n with the external data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_BUFFER_HEADER_T {
    #[doc = "< Used to link several buffer headers together"]
    pub next: *mut MMAL_BUFFER_HEADER_T,
    #[doc = "< Data private to the framework"]
    pub priv_: *mut MMAL_BUFFER_HEADER_PRIVATE_T,
    #[doc = "< Defines what the buffer header contains. This is a FourCC\nwith 0 as a special value meaning stream data"]
    pub cmd: u32,
    #[doc = "< Pointer to the start of the payload buffer (should not be\nchanged by component)"]
    pub data: *mut u8,
    #[doc = "< Allocated size in bytes of payload buffer"]
    pub alloc_size: u32,
    #[doc = "< Number of bytes currently used in the payload buffer (starting\nfrom offset)"]
    pub length: u32,
    #[doc = "< Offset in bytes to the start of valid data in the payload buffer"]
    pub offset: u32,
    #[doc = "< Flags describing properties of a buffer header (see\n\\ref bufferheaderflags \"Buffer header flags\")"]
    pub flags: u32,
    #[doc = "< Presentation timestamp in microseconds. \\ref MMAL_TIME_UNKNOWN\nis used when the pts is unknown."]
    pub pts: i64,
    #[doc = "< Decode timestamp in microseconds (dts = pts, except in the case\nof video streams with B frames). \\ref MMAL_TIME_UNKNOWN\nis used when the dts is unknown."]
    pub dts: i64,
    #[doc = " Type specific data that's associated with a payload buffer"]
    pub type_: *mut MMAL_BUFFER_HEADER_TYPE_SPECIFIC_T,
    #[doc = "< Field reserved for use by the client"]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MMAL_BUFFER_HEADER_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_BUFFER_HEADER_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_BUFFER_HEADER_T>(),
        80usize,
        concat!("Size of: ", stringify!(MMAL_BUFFER_HEADER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_BUFFER_HEADER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_BUFFER_HEADER_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_BUFFER_HEADER_T),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    #[doc = " Acquire a buffer header.\n Acquiring a buffer header increases a reference counter on it and makes sure that the\n buffer header won't be recycled until all the references to it are gone.\n This is useful for instance if a component needs to return a buffer header but still needs\n access to it for some internal processing (e.g. reference frames in video codecs).\n\n @param header buffer header to acquire"]
    pub fn mmal_buffer_header_acquire(header: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Reset a buffer header.\n Resets all header variables to default values.\n\n @param header buffer header to reset"]
    pub fn mmal_buffer_header_reset(header: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Release a buffer header.\n Releasing a buffer header will decrease its reference counter and when no more references\n are left, the buffer header will be recycled by calling its 'release' callback function.\n\n If a pre-release callback is set (\\ref MMAL_BH_PRE_RELEASE_CB_T), this will be invoked\n before calling the buffer's release callback and potentially postpone buffer recycling.\n Once pre-release is complete the buffer header is recycled with\n \\ref mmal_buffer_header_release_continue.\n\n @param header buffer header to release"]
    pub fn mmal_buffer_header_release(header: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Continue the buffer header release process.\n This should be called to complete buffer header recycling once all pre-release activity\n has been completed.\n\n @param header buffer header to release"]
    pub fn mmal_buffer_header_release_continue(header: *mut MMAL_BUFFER_HEADER_T);
}
#[doc = " Buffer header pre-release callback.\n The callback is invoked just before a buffer is released back into a\n pool. This is used by clients who need to trigger additional actions\n before the buffer can finally be released (e.g. wait for a bulk transfer\n to complete).\n\n The callback should return TRUE if the buffer release need to be post-poned.\n\n @param header   buffer header about to be released\n @param userdata user-specific data\n\n @return TRUE if the buffer should not be released"]
pub type MMAL_BH_PRE_RELEASE_CB_T = ::std::option::Option<
    unsafe extern "C" fn(
        header: *mut MMAL_BUFFER_HEADER_T,
        userdata: *mut ::std::os::raw::c_void,
    ) -> MMAL_BOOL_T,
>;
extern "C" {
    #[doc = " Set a buffer header pre-release callback.\n If the callback is NULL, the buffer will be released back into the pool\n immediately as usual.\n\n @param header   buffer header to associate callback with\n @param cb       pre-release callback to invoke\n @param userdata user-specific data"]
    pub fn mmal_buffer_header_pre_release_cb_set(
        header: *mut MMAL_BUFFER_HEADER_T,
        cb: MMAL_BH_PRE_RELEASE_CB_T,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Replicate a buffer header into another one.\n Replicating a buffer header will not only do an exact copy of all the public fields of the\n buffer header (including data and alloc_size), but it will also acquire a reference to the\n source buffer header which will only be released once the replicate has been released.\n\n @param dest buffer header into which to replicate\n @param src buffer header to use as the source for the replication\n @return MMAL_SUCCESS on success"]
    pub fn mmal_buffer_header_replicate(
        dest: *mut MMAL_BUFFER_HEADER_T,
        src: *mut MMAL_BUFFER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Lock the data buffer contained in the buffer header in memory.\n This call does nothing on all platforms except VideoCore where it is needed to pin a\n buffer in memory before any access to it.\n\n @param header buffer header to lock"]
    pub fn mmal_buffer_header_mem_lock(header: *mut MMAL_BUFFER_HEADER_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Unlock the data buffer contained in the buffer header.\n This call does nothing on all platforms except VideoCore where it is needed to un-pin a\n buffer in memory after any access to it.\n\n @param header buffer header to unlock"]
    pub fn mmal_buffer_header_mem_unlock(header: *mut MMAL_BUFFER_HEADER_T);
}
#[doc = "< Never a valid parameter ID"]
pub const MMAL_PARAMETER_UNUSED: _bindgen_ty_23 = 0;
#[doc = "< Takes a MMAL_PARAMETER_ENCODING_T"]
pub const MMAL_PARAMETER_SUPPORTED_ENCODINGS: _bindgen_ty_23 = 1;
#[doc = "< Takes a MMAL_PARAMETER_URI_T"]
pub const MMAL_PARAMETER_URI: _bindgen_ty_23 = 2;
#[doc = "< Takes a MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T"]
pub const MMAL_PARAMETER_CHANGE_EVENT_REQUEST: _bindgen_ty_23 = 3;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ZERO_COPY: _bindgen_ty_23 = 4;
#[doc = "< Takes a MMAL_PARAMETER_BUFFER_REQUIREMENTS_T"]
pub const MMAL_PARAMETER_BUFFER_REQUIREMENTS: _bindgen_ty_23 = 5;
#[doc = "< Takes a MMAL_PARAMETER_STATISTICS_T"]
pub const MMAL_PARAMETER_STATISTICS: _bindgen_ty_23 = 6;
#[doc = "< Takes a MMAL_PARAMETER_CORE_STATISTICS_T"]
pub const MMAL_PARAMETER_CORE_STATISTICS: _bindgen_ty_23 = 7;
#[doc = "< Takes a MMAL_PARAMETER_MEM_USAGE_T"]
pub const MMAL_PARAMETER_MEM_USAGE: _bindgen_ty_23 = 8;
#[doc = "< Takes a MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_BUFFER_FLAG_FILTER: _bindgen_ty_23 = 9;
#[doc = "< Takes a MMAL_PARAMETER_SEEK_T"]
pub const MMAL_PARAMETER_SEEK: _bindgen_ty_23 = 10;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_POWERMON_ENABLE: _bindgen_ty_23 = 11;
#[doc = "< Takes a MMAL_PARAMETER_LOGGING_T"]
pub const MMAL_PARAMETER_LOGGING: _bindgen_ty_23 = 12;
#[doc = "< Takes a MMAL_PARAMETER_UINT64_T"]
pub const MMAL_PARAMETER_SYSTEM_TIME: _bindgen_ty_23 = 13;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_NO_IMAGE_PADDING: _bindgen_ty_23 = 14;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_LOCKSTEP_ENABLE: _bindgen_ty_23 = 15;
#[doc = " Common MMAL parameter IDs."]
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
#[doc = " Parameter header type. All parameter structures need to begin with this type.\n The \\ref id field must be set to a parameter ID, such as one of those listed on\n the \\ref MMAL_PARAMETER_IDS \"Pre-defined MMAL parameter IDs\" page."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_HEADER_T {
    #[doc = "< Parameter ID."]
    pub id: u32,
    #[doc = "< Size in bytes of the parameter (including the header)"]
    pub size: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_HEADER_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_HEADER_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_HEADER_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_HEADER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_HEADER_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_HEADER_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_HEADER_T),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_HEADER_T),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Change event request parameter type.\n This is used to control whether a \\ref MMAL_EVENT_PARAMETER_CHANGED_T event\n is issued should a given parameter change."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< ID of parameter that may change, see \\ref MMAL_PARAMETER_IDS"]
    pub change_id: u32,
    #[doc = "< True if the event is enabled, false if disabled"]
    pub enable: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T),
            "::",
            stringify!(change_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CHANGE_EVENT_REQUEST_T),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Buffer requirements parameter.\n This is mainly used to increase the requirements of a component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BUFFER_REQUIREMENTS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Minimum number of buffers the port requires"]
    pub buffer_num_min: u32,
    #[doc = "< Minimum size of buffers the port requires"]
    pub buffer_size_min: u32,
    #[doc = "< Minimum alignment requirement for the buffers.\nA value of zero means no special alignment requirements."]
    pub buffer_alignment_min: u32,
    #[doc = "< Number of buffers the port recommends for optimal performance.\nA value of zero means no special recommendation."]
    pub buffer_num_recommended: u32,
    #[doc = "< Size of buffers the port recommends for optimal performance.\nA value of zero means no special recommendation."]
    pub buffer_size_recommended: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BUFFER_REQUIREMENTS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BUFFER_REQUIREMENTS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num_min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_num_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_min) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_size_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_alignment_min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_alignment_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num_recommended) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_num_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_recommended) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BUFFER_REQUIREMENTS_T),
            "::",
            stringify!(buffer_size_recommended)
        )
    );
}
#[doc = " Seek request parameter type.\n This is used to issue a seek request to a source component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SEEK_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Offset (in microseconds) to seek to"]
    pub offset: i64,
    #[doc = "< Seeking flags"]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SEEK_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_SEEK_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SEEK_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SEEK_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SEEK_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_SEEK_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SEEK_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SEEK_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SEEK_T),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Port statistics for debugging/test purposes.\n Ports may support query of this parameter to return statistics for debugging or\n test purposes. Not all values may be relevant for a given port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_STATISTICS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Total number of buffers processed"]
    pub buffer_count: u32,
    #[doc = "< Total number of frames processed"]
    pub frame_count: u32,
    #[doc = "< Number of frames without expected PTS based on frame rate"]
    pub frames_skipped: u32,
    #[doc = "< Number of frames discarded"]
    pub frames_discarded: u32,
    #[doc = "< Set if the end of stream has been reached"]
    pub eos_seen: u32,
    #[doc = "< Maximum frame size in bytes"]
    pub maximum_frame_bytes: u32,
    #[doc = "< Total number of bytes processed"]
    pub total_bytes: i64,
    #[doc = "< Number of corrupt macroblocks in the stream"]
    pub corrupt_macroblocks: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_STATISTICS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_STATISTICS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_STATISTICS_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_STATISTICS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_STATISTICS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(frame_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames_skipped) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(frames_skipped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames_discarded) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(frames_discarded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eos_seen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(eos_seen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum_frame_bytes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(maximum_frame_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_bytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(total_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrupt_macroblocks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STATISTICS_T),
            "::",
            stringify!(corrupt_macroblocks)
        )
    );
}
pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_RX: MMAL_CORE_STATS_DIR = 0;
pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_TX: MMAL_CORE_STATS_DIR = 1;
pub const MMAL_CORE_STATS_DIR_MMAL_CORE_STATS_MAX: MMAL_CORE_STATS_DIR = 2147483647;
pub type MMAL_CORE_STATS_DIR = ::std::os::raw::c_uint;
#[doc = " MMAL core statistics. These are collected by the core itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CORE_STATISTICS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub dir: MMAL_CORE_STATS_DIR,
    #[doc = "< Reset to zero after reading"]
    pub reset: MMAL_BOOL_T,
    #[doc = "< The statistics"]
    pub stats: MMAL_CORE_STATISTICS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CORE_STATISTICS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CORE_STATISTICS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CORE_STATISTICS_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CORE_STATISTICS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CORE_STATISTICS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CORE_STATISTICS_T),
            "::",
            stringify!(stats)
        )
    );
}
#[doc = " Component memory usage statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_MEM_USAGE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub pool_mem_alloc_size: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_MEM_USAGE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_MEM_USAGE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_MEM_USAGE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_MEM_USAGE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_MEM_USAGE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_MEM_USAGE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MEM_USAGE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_mem_alloc_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MEM_USAGE_T),
            "::",
            stringify!(pool_mem_alloc_size)
        )
    );
}
#[doc = " Logging control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_LOGGING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Logging bits to set"]
    pub set: u32,
    #[doc = "< Logging bits to clear"]
    pub clear: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_LOGGING_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_LOGGING_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_LOGGING_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_LOGGING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_LOGGING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_LOGGING_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LOGGING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LOGGING_T),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LOGGING_T),
            "::",
            stringify!(clear)
        )
    );
}
#[doc = "< Takes a @ref MMAL_PARAMETER_THUMBNAIL_CONFIG_T"]
pub const MMAL_PARAMETER_THUMBNAIL_CONFIGURATION: _bindgen_ty_24 = 65536;
#[doc = "< Unused?"]
pub const MMAL_PARAMETER_CAPTURE_QUALITY: _bindgen_ty_24 = 65537;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_ROTATION: _bindgen_ty_24 = 65538;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_EXIF_DISABLE: _bindgen_ty_24 = 65539;
#[doc = "< Takes a @ref MMAL_PARAMETER_EXIF_T"]
pub const MMAL_PARAMETER_EXIF: _bindgen_ty_24 = 65540;
#[doc = "< Takes a @ref MMAL_PARAM_AWBMODE_T"]
pub const MMAL_PARAMETER_AWB_MODE: _bindgen_ty_24 = 65541;
#[doc = "< Takes a @ref MMAL_PARAMETER_IMAGEFX_T"]
pub const MMAL_PARAMETER_IMAGE_EFFECT: _bindgen_ty_24 = 65542;
#[doc = "< Takes a @ref MMAL_PARAMETER_COLOURFX_T"]
pub const MMAL_PARAMETER_COLOUR_EFFECT: _bindgen_ty_24 = 65543;
#[doc = "< Takes a @ref MMAL_PARAMETER_FLICKERAVOID_T"]
pub const MMAL_PARAMETER_FLICKER_AVOID: _bindgen_ty_24 = 65544;
#[doc = "< Takes a @ref MMAL_PARAMETER_FLASH_T"]
pub const MMAL_PARAMETER_FLASH: _bindgen_ty_24 = 65545;
#[doc = "< Takes a @ref MMAL_PARAMETER_REDEYE_T"]
pub const MMAL_PARAMETER_REDEYE: _bindgen_ty_24 = 65546;
#[doc = "< Takes a @ref MMAL_PARAMETER_FOCUS_T"]
pub const MMAL_PARAMETER_FOCUS: _bindgen_ty_24 = 65547;
#[doc = "< Unused?"]
pub const MMAL_PARAMETER_FOCAL_LENGTHS: _bindgen_ty_24 = 65548;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T or MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_EXPOSURE_COMP: _bindgen_ty_24 = 65549;
#[doc = "< Takes a @ref MMAL_PARAMETER_SCALEFACTOR_T"]
pub const MMAL_PARAMETER_ZOOM: _bindgen_ty_24 = 65550;
#[doc = "< Takes a @ref MMAL_PARAMETER_MIRROR_T"]
pub const MMAL_PARAMETER_MIRROR: _bindgen_ty_24 = 65551;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_NUM: _bindgen_ty_24 = 65552;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CAPTURE: _bindgen_ty_24 = 65553;
#[doc = "< Takes a @ref MMAL_PARAMETER_EXPOSUREMODE_T"]
pub const MMAL_PARAMETER_EXPOSURE_MODE: _bindgen_ty_24 = 65554;
#[doc = "< Takes a @ref MMAL_PARAMETER_EXPOSUREMETERINGMODE_T"]
pub const MMAL_PARAMETER_EXP_METERING_MODE: _bindgen_ty_24 = 65555;
#[doc = "< Takes a @ref MMAL_PARAMETER_FOCUS_STATUS_T"]
pub const MMAL_PARAMETER_FOCUS_STATUS: _bindgen_ty_24 = 65556;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_CONFIG_T"]
pub const MMAL_PARAMETER_CAMERA_CONFIG: _bindgen_ty_24 = 65557;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAPTURE_STATUS_T"]
pub const MMAL_PARAMETER_CAPTURE_STATUS: _bindgen_ty_24 = 65558;
#[doc = "< Takes a @ref MMAL_PARAMETER_FACE_TRACK_T"]
pub const MMAL_PARAMETER_FACE_TRACK: _bindgen_ty_24 = 65559;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_DRAW_BOX_FACES_AND_FOCUS: _bindgen_ty_24 = 65560;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_JPEG_Q_FACTOR: _bindgen_ty_24 = 65561;
#[doc = "< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T"]
pub const MMAL_PARAMETER_FRAME_RATE: _bindgen_ty_24 = 65562;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_STC_MODE_T"]
pub const MMAL_PARAMETER_USE_STC: _bindgen_ty_24 = 65563;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_INFO_T"]
pub const MMAL_PARAMETER_CAMERA_INFO: _bindgen_ty_24 = 65564;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_STABILISATION: _bindgen_ty_24 = 65565;
#[doc = "< Takes a @ref MMAL_PARAMETER_FACE_TRACK_RESULTS_T"]
pub const MMAL_PARAMETER_FACE_TRACK_RESULTS: _bindgen_ty_24 = 65566;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ENABLE_RAW_CAPTURE: _bindgen_ty_24 = 65567;
#[doc = "< Takes a @ref MMAL_PARAMETER_URI_T"]
pub const MMAL_PARAMETER_DPF_FILE: _bindgen_ty_24 = 65568;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ENABLE_DPF_FILE: _bindgen_ty_24 = 65569;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_DPF_FAIL_IS_FATAL: _bindgen_ty_24 = 65570;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAPTUREMODE_T"]
pub const MMAL_PARAMETER_CAPTURE_MODE: _bindgen_ty_24 = 65571;
#[doc = "< Takes a @ref MMAL_PARAMETER_FOCUS_REGIONS_T"]
pub const MMAL_PARAMETER_FOCUS_REGIONS: _bindgen_ty_24 = 65572;
#[doc = "< Takes a @ref MMAL_PARAMETER_INPUT_CROP_T"]
pub const MMAL_PARAMETER_INPUT_CROP: _bindgen_ty_24 = 65573;
#[doc = "< Takes a @ref MMAL_PARAMETER_SENSOR_INFORMATION_T"]
pub const MMAL_PARAMETER_SENSOR_INFORMATION: _bindgen_ty_24 = 65574;
#[doc = "< Takes a @ref MMAL_PARAMETER_FLASH_SELECT_T"]
pub const MMAL_PARAMETER_FLASH_SELECT: _bindgen_ty_24 = 65575;
#[doc = "< Takes a @ref MMAL_PARAMETER_FIELD_OF_VIEW_T"]
pub const MMAL_PARAMETER_FIELD_OF_VIEW: _bindgen_ty_24 = 65576;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_HIGH_DYNAMIC_RANGE: _bindgen_ty_24 = 65577;
#[doc = "< Takes a @ref MMAL_PARAMETER_DRC_T"]
pub const MMAL_PARAMETER_DYNAMIC_RANGE_COMPRESSION: _bindgen_ty_24 = 65578;
#[doc = "< Takes a @ref MMAL_PARAMETER_ALGORITHM_CONTROL_T"]
pub const MMAL_PARAMETER_ALGORITHM_CONTROL: _bindgen_ty_24 = 65579;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_SHARPNESS: _bindgen_ty_24 = 65580;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_CONTRAST: _bindgen_ty_24 = 65581;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_BRIGHTNESS: _bindgen_ty_24 = 65582;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_SATURATION: _bindgen_ty_24 = 65583;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_ISO: _bindgen_ty_24 = 65584;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ANTISHAKE: _bindgen_ty_24 = 65585;
#[doc = "< Takes a @ref MMAL_PARAMETER_IMAGEFX_PARAMETERS_T"]
pub const MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS: _bindgen_ty_24 = 65586;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CAMERA_BURST_CAPTURE: _bindgen_ty_24 = 65587;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_MIN_ISO: _bindgen_ty_24 = 65588;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_USE_CASE_T"]
pub const MMAL_PARAMETER_CAMERA_USE_CASE: _bindgen_ty_24 = 65589;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CAPTURE_STATS_PASS: _bindgen_ty_24 = 65590;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_CUSTOM_SENSOR_CONFIG: _bindgen_ty_24 = 65591;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_ENABLE_REGISTER_FILE: _bindgen_ty_24 = 65592;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_REGISTER_FAIL_IS_FATAL: _bindgen_ty_24 = 65593;
#[doc = "< Takes a @ref MMAL_PARAMETER_CONFIGFILE_T"]
pub const MMAL_PARAMETER_CONFIGFILE_REGISTERS: _bindgen_ty_24 = 65594;
#[doc = "< Takes a @ref MMAL_PARAMETER_CONFIGFILE_CHUNK_T"]
pub const MMAL_PARAMETER_CONFIGFILE_CHUNK_REGISTERS: _bindgen_ty_24 = 65595;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_JPEG_ATTACH_LOG: _bindgen_ty_24 = 65596;
#[doc = "< Takes a @ref MMAL_PARAMETER_ZEROSHUTTERLAG_T"]
pub const MMAL_PARAMETER_ZERO_SHUTTER_LAG: _bindgen_ty_24 = 65597;
#[doc = "< Takes a @ref MMAL_PARAMETER_FPS_RANGE_T"]
pub const MMAL_PARAMETER_FPS_RANGE: _bindgen_ty_24 = 65598;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_CAPTURE_EXPOSURE_COMP: _bindgen_ty_24 = 65599;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_SW_SHARPEN_DISABLE: _bindgen_ty_24 = 65600;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_FLASH_REQUIRED: _bindgen_ty_24 = 65601;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_SW_SATURATION_DISABLE: _bindgen_ty_24 = 65602;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_SHUTTER_SPEED: _bindgen_ty_24 = 65603;
#[doc = "< Takes a @ref MMAL_PARAMETER_AWB_GAINS_T"]
pub const MMAL_PARAMETER_CUSTOM_AWB_GAINS: _bindgen_ty_24 = 65604;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_SETTINGS_T"]
pub const MMAL_PARAMETER_CAMERA_SETTINGS: _bindgen_ty_24 = 65605;
#[doc = "< Takes a @ref MMAL_PARAMETER_PRIVACY_INDICATOR_T"]
pub const MMAL_PARAMETER_PRIVACY_INDICATOR: _bindgen_ty_24 = 65606;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_DENOISE: _bindgen_ty_24 = 65607;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_STILLS_DENOISE: _bindgen_ty_24 = 65608;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_ANNOTATE_T"]
pub const MMAL_PARAMETER_ANNOTATE: _bindgen_ty_24 = 65609;
#[doc = "< Takes a @ref MMAL_PARAMETER_STEREOSCOPIC_MODE_T"]
pub const MMAL_PARAMETER_STEREOSCOPIC_MODE: _bindgen_ty_24 = 65610;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_INTERFACE_T"]
pub const MMAL_PARAMETER_CAMERA_INTERFACE: _bindgen_ty_24 = 65611;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T"]
pub const MMAL_PARAMETER_CAMERA_CLOCKING_MODE: _bindgen_ty_24 = 65612;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_RX_CONFIG_T"]
pub const MMAL_PARAMETER_CAMERA_RX_CONFIG: _bindgen_ty_24 = 65613;
#[doc = "< Takes a @ref MMAL_PARAMETER_CAMERA_RX_TIMING_T"]
pub const MMAL_PARAMETER_CAMERA_RX_TIMING: _bindgen_ty_24 = 65614;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_DPF_CONFIG: _bindgen_ty_24 = 65615;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_JPEG_RESTART_INTERVAL: _bindgen_ty_24 = 65616;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_CAMERA_ISP_BLOCK_OVERRIDE: _bindgen_ty_24 = 65617;
#[doc = "< Takes a @ref MMAL_PARAMETER_LENS_SHADING_T"]
pub const MMAL_PARAMETER_LENS_SHADING_OVERRIDE: _bindgen_ty_24 = 65618;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T  or @ref MMAL_PARAMETER_BLACK_LEVEL_T"]
pub const MMAL_PARAMETER_BLACK_LEVEL: _bindgen_ty_24 = 65619;
#[doc = "< Takes a @ref MMAL_PARAMETER_RESIZE_T"]
pub const MMAL_PARAMETER_RESIZE_PARAMS: _bindgen_ty_24 = 65620;
#[doc = "< Takes a @ref MMAL_PARAMETER_CROP_T"]
pub const MMAL_PARAMETER_CROP: _bindgen_ty_24 = 65621;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_OUTPUT_SHIFT: _bindgen_ty_24 = 65622;
#[doc = "< Takes a @ref MMAL_PARAMETER_INT32_T"]
pub const MMAL_PARAMETER_CCM_SHIFT: _bindgen_ty_24 = 65623;
#[doc = "< Takes a @ref MMAL_PARAMETER_CUSTOM_CCM_T"]
pub const MMAL_PARAMETER_CUSTOM_CCM: _bindgen_ty_24 = 65624;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_ANALOG_GAIN: _bindgen_ty_24 = 65625;
#[doc = "< Takes a @ref MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_DIGITAL_GAIN: _bindgen_ty_24 = 65626;
#[doc = "< Takes a @ref MMAL_PARAMETER_DENOISE_T"]
pub const MMAL_PARAMETER_DENOISE: _bindgen_ty_24 = 65627;
#[doc = "< Takes a @ref MMAL_PARAMETER_SHARPEN_T"]
pub const MMAL_PARAMETER_SHARPEN: _bindgen_ty_24 = 65628;
#[doc = "< Takes a @ref MMAL_PARAMETER_GREEN_EQ_T"]
pub const MMAL_PARAMETER_GREEN_EQ: _bindgen_ty_24 = 65629;
#[doc = "< Tales a @ref MMAP_PARAMETER_DPC_T"]
pub const MMAL_PARAMETER_DPC: _bindgen_ty_24 = 65630;
#[doc = "< Tales a @ref MMAP_PARAMETER_GAMMA_T"]
pub const MMAL_PARAMETER_GAMMA: _bindgen_ty_24 = 65631;
#[doc = "< Takes a @ref MMAL_PARAMETER_CDN_T"]
pub const MMAL_PARAMETER_CDN: _bindgen_ty_24 = 65632;
#[doc = " Camera-specific MMAL parameter IDs.\n @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
#[doc = " Thumbnail configuration parameter type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_THUMBNAIL_CONFIG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable generation of thumbnails during still capture"]
    pub enable: u32,
    #[doc = "< Desired width of the thumbnail"]
    pub width: u32,
    #[doc = "< Desired height of the thumbnail"]
    pub height: u32,
    #[doc = "< Desired compression quality of the thumbnail"]
    pub quality: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_THUMBNAIL_CONFIG_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_THUMBNAIL_CONFIG_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_THUMBNAIL_CONFIG_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_THUMBNAIL_CONFIG_T),
            "::",
            stringify!(quality)
        )
    );
}
#[doc = " EXIF parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_EXIF_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< If 0, assume key is terminated by '=', otherwise length of key and treat data as binary"]
    pub keylen: u32,
    #[doc = "< Offset within data buffer of the start of the value. If 0, look for a \"key=value\" string"]
    pub value_offset: u32,
    #[doc = "< If 0, assume value is null-terminated, otherwise length of value and treat data as binary"]
    pub valuelen: u32,
    #[doc = "< EXIF key/value string. Variable length"]
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_EXIF_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_EXIF_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_EXIF_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_EXIF_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_EXIF_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_EXIF_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(value_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valuelen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(valuelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXIF_T),
            "::",
            stringify!(data)
        )
    );
}
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_OFF: MMAL_PARAM_EXPOSUREMODE_T = 0;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_AUTO: MMAL_PARAM_EXPOSUREMODE_T = 1;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_NIGHT: MMAL_PARAM_EXPOSUREMODE_T = 2;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_NIGHTPREVIEW:
    MMAL_PARAM_EXPOSUREMODE_T = 3;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_BACKLIGHT: MMAL_PARAM_EXPOSUREMODE_T =
    4;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SPOTLIGHT: MMAL_PARAM_EXPOSUREMODE_T =
    5;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SPORTS: MMAL_PARAM_EXPOSUREMODE_T = 6;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_SNOW: MMAL_PARAM_EXPOSUREMODE_T = 7;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_BEACH: MMAL_PARAM_EXPOSUREMODE_T = 8;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_VERYLONG: MMAL_PARAM_EXPOSUREMODE_T = 9;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_FIXEDFPS: MMAL_PARAM_EXPOSUREMODE_T =
    10;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_ANTISHAKE: MMAL_PARAM_EXPOSUREMODE_T =
    11;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_FIREWORKS: MMAL_PARAM_EXPOSUREMODE_T =
    12;
pub const MMAL_PARAM_EXPOSUREMODE_T_MMAL_PARAM_EXPOSUREMODE_MAX: MMAL_PARAM_EXPOSUREMODE_T =
    2147483647;
#[doc = " Exposure modes."]
pub type MMAL_PARAM_EXPOSUREMODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_EXPOSUREMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< exposure mode"]
    pub value: MMAL_PARAM_EXPOSUREMODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_EXPOSUREMODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_EXPOSUREMODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_EXPOSUREMODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_EXPOSUREMODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_EXPOSUREMODE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_EXPOSUREMODE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_AVERAGE:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 0;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_SPOT:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 1;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_BACKLIT:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 2;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_MATRIX:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 3;
pub const MMAL_PARAM_EXPOSUREMETERINGMODE_T_MMAL_PARAM_EXPOSUREMETERINGMODE_MAX:
    MMAL_PARAM_EXPOSUREMETERINGMODE_T = 2147483647;
pub type MMAL_PARAM_EXPOSUREMETERINGMODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_EXPOSUREMETERINGMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< metering mode"]
    pub value: MMAL_PARAM_EXPOSUREMETERINGMODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_EXPOSUREMETERINGMODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_EXPOSUREMETERINGMODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_EXPOSUREMETERINGMODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_OFF: MMAL_PARAM_AWBMODE_T = 0;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_AUTO: MMAL_PARAM_AWBMODE_T = 1;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_SUNLIGHT: MMAL_PARAM_AWBMODE_T = 2;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_CLOUDY: MMAL_PARAM_AWBMODE_T = 3;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_SHADE: MMAL_PARAM_AWBMODE_T = 4;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_TUNGSTEN: MMAL_PARAM_AWBMODE_T = 5;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_FLUORESCENT: MMAL_PARAM_AWBMODE_T = 6;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_INCANDESCENT: MMAL_PARAM_AWBMODE_T = 7;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_FLASH: MMAL_PARAM_AWBMODE_T = 8;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_HORIZON: MMAL_PARAM_AWBMODE_T = 9;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_GREYWORLD: MMAL_PARAM_AWBMODE_T = 10;
pub const MMAL_PARAM_AWBMODE_T_MMAL_PARAM_AWBMODE_MAX: MMAL_PARAM_AWBMODE_T = 2147483647;
#[doc = " AWB parameter modes."]
pub type MMAL_PARAM_AWBMODE_T = ::std::os::raw::c_uint;
#[doc = " AWB parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_AWBMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< AWB mode"]
    pub value: MMAL_PARAM_AWBMODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_AWBMODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_AWBMODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_AWBMODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_AWBMODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_AWBMODE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_AWBMODE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWBMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWBMODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_NONE: MMAL_PARAM_IMAGEFX_T = 0;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_NEGATIVE: MMAL_PARAM_IMAGEFX_T = 1;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SOLARIZE: MMAL_PARAM_IMAGEFX_T = 2;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_POSTERIZE: MMAL_PARAM_IMAGEFX_T = 3;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WHITEBOARD: MMAL_PARAM_IMAGEFX_T = 4;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_BLACKBOARD: MMAL_PARAM_IMAGEFX_T = 5;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SKETCH: MMAL_PARAM_IMAGEFX_T = 6;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DENOISE: MMAL_PARAM_IMAGEFX_T = 7;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_EMBOSS: MMAL_PARAM_IMAGEFX_T = 8;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_OILPAINT: MMAL_PARAM_IMAGEFX_T = 9;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_HATCH: MMAL_PARAM_IMAGEFX_T = 10;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_GPEN: MMAL_PARAM_IMAGEFX_T = 11;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_PASTEL: MMAL_PARAM_IMAGEFX_T = 12;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WATERCOLOUR: MMAL_PARAM_IMAGEFX_T = 13;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_FILM: MMAL_PARAM_IMAGEFX_T = 14;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_BLUR: MMAL_PARAM_IMAGEFX_T = 15;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_SATURATION: MMAL_PARAM_IMAGEFX_T = 16;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURSWAP: MMAL_PARAM_IMAGEFX_T = 17;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_WASHEDOUT: MMAL_PARAM_IMAGEFX_T = 18;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_POSTERISE: MMAL_PARAM_IMAGEFX_T = 19;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURPOINT: MMAL_PARAM_IMAGEFX_T = 20;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_COLOURBALANCE: MMAL_PARAM_IMAGEFX_T = 21;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_CARTOON: MMAL_PARAM_IMAGEFX_T = 22;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_DOUBLE: MMAL_PARAM_IMAGEFX_T = 23;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV: MMAL_PARAM_IMAGEFX_T = 24;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST: MMAL_PARAM_IMAGEFX_T = 25;
pub const MMAL_PARAM_IMAGEFX_T_MMAL_PARAM_IMAGEFX_MAX: MMAL_PARAM_IMAGEFX_T = 2147483647;
#[doc = " Image effect"]
pub type MMAL_PARAM_IMAGEFX_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_IMAGEFX_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Image effect mode"]
    pub value: MMAL_PARAM_IMAGEFX_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_IMAGEFX_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_IMAGEFX_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_IMAGEFX_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_IMAGEFX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_IMAGEFX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_IMAGEFX_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_T),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_IMAGEFX_PARAMETERS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Image effect mode"]
    pub effect: MMAL_PARAM_IMAGEFX_T,
    #[doc = "< Number of used elements in"]
    pub num_effect_params: u32,
    #[doc = "< Array of parameters"]
    pub effect_parameter: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_IMAGEFX_PARAMETERS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_IMAGEFX_PARAMETERS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).effect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(effect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_effect_params) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(num_effect_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).effect_parameter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_IMAGEFX_PARAMETERS_T),
            "::",
            stringify!(effect_parameter)
        )
    );
}
#[doc = " Colour effect parameter type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_COLOURFX_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: i32,
    pub u: u32,
    pub v: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_COLOURFX_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_COLOURFX_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_COLOURFX_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_COLOURFX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_COLOURFX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_COLOURFX_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_COLOURFX_T),
            "::",
            stringify!(v)
        )
    );
}
#[doc = "< Frames do not have STCs, as needed in OpenMAX/IL"]
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_OFF: MMAL_CAMERA_STC_MODE_T = 0;
#[doc = "< Use raw clock STC, needed for true pause/resume support"]
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_RAW: MMAL_CAMERA_STC_MODE_T = 1;
#[doc = "< Start the STC from the start of capture, only for quick demo code"]
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_COOKED: MMAL_CAMERA_STC_MODE_T = 2;
pub const MMAL_CAMERA_STC_MODE_T_MMAL_PARAM_STC_MODE_MAX: MMAL_CAMERA_STC_MODE_T = 2147483647;
pub type MMAL_CAMERA_STC_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_STC_MODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CAMERA_STC_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_STC_MODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_STC_MODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_STC_MODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_STC_MODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_STC_MODE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_OFF: MMAL_PARAM_FLICKERAVOID_T = 0;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_AUTO: MMAL_PARAM_FLICKERAVOID_T = 1;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_50HZ: MMAL_PARAM_FLICKERAVOID_T = 2;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_60HZ: MMAL_PARAM_FLICKERAVOID_T = 3;
pub const MMAL_PARAM_FLICKERAVOID_T_MMAL_PARAM_FLICKERAVOID_MAX: MMAL_PARAM_FLICKERAVOID_T =
    2147483647;
pub type MMAL_PARAM_FLICKERAVOID_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FLICKERAVOID_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Flicker avoidance mode"]
    pub value: MMAL_PARAM_FLICKERAVOID_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FLICKERAVOID_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FLICKERAVOID_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FLICKERAVOID_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FLICKERAVOID_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FLICKERAVOID_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FLICKERAVOID_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLICKERAVOID_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLICKERAVOID_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_OFF: MMAL_PARAM_FLASH_T = 0;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_AUTO: MMAL_PARAM_FLASH_T = 1;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_ON: MMAL_PARAM_FLASH_T = 2;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_REDEYE: MMAL_PARAM_FLASH_T = 3;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_FILLIN: MMAL_PARAM_FLASH_T = 4;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_TORCH: MMAL_PARAM_FLASH_T = 5;
pub const MMAL_PARAM_FLASH_T_MMAL_PARAM_FLASH_MAX: MMAL_PARAM_FLASH_T = 2147483647;
pub type MMAL_PARAM_FLASH_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FLASH_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Flash mode"]
    pub value: MMAL_PARAM_FLASH_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FLASH_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FLASH_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FLASH_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FLASH_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FLASH_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FLASH_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_OFF: MMAL_PARAM_REDEYE_T = 0;
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_ON: MMAL_PARAM_REDEYE_T = 1;
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_SIMPLE: MMAL_PARAM_REDEYE_T = 2;
pub const MMAL_PARAM_REDEYE_T_MMAL_PARAM_REDEYE_MAX: MMAL_PARAM_REDEYE_T = 2147483647;
pub type MMAL_PARAM_REDEYE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_REDEYE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Red eye reduction mode"]
    pub value: MMAL_PARAM_REDEYE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_REDEYE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_REDEYE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_REDEYE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_REDEYE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_REDEYE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_REDEYE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_REDEYE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_REDEYE_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO: MMAL_PARAM_FOCUS_T = 0;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO_NEAR: MMAL_PARAM_FOCUS_T = 1;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_AUTO_MACRO: MMAL_PARAM_FOCUS_T = 2;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF: MMAL_PARAM_FOCUS_T = 3;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_NEAR: MMAL_PARAM_FOCUS_T = 4;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_INFINITY: MMAL_PARAM_FOCUS_T = 5;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_HYPERFOCAL: MMAL_PARAM_FOCUS_T = 6;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_NEAR: MMAL_PARAM_FOCUS_T = 7;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_MACRO: MMAL_PARAM_FOCUS_T = 8;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_EDOF: MMAL_PARAM_FOCUS_T = 9;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_MACRO: MMAL_PARAM_FOCUS_T = 10;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_FAST: MMAL_PARAM_FOCUS_T = 11;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_NEAR_FAST: MMAL_PARAM_FOCUS_T = 12;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_CAF_MACRO_FAST: MMAL_PARAM_FOCUS_T = 13;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_FIXED_CURRENT: MMAL_PARAM_FOCUS_T = 14;
pub const MMAL_PARAM_FOCUS_T_MMAL_PARAM_FOCUS_MAX: MMAL_PARAM_FOCUS_T = 2147483647;
pub type MMAL_PARAM_FOCUS_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Focus mode"]
    pub value: MMAL_PARAM_FOCUS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FOCUS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_T),
            "::",
            stringify!(value)
        )
    );
}
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_NOT_CAPTURING:
    MMAL_PARAM_CAPTURE_STATUS_T = 0;
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_CAPTURE_STARTED:
    MMAL_PARAM_CAPTURE_STATUS_T = 1;
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_CAPTURE_ENDED:
    MMAL_PARAM_CAPTURE_STATUS_T = 2;
pub const MMAL_PARAM_CAPTURE_STATUS_T_MMAL_PARAM_CAPTURE_STATUS_MAX: MMAL_PARAM_CAPTURE_STATUS_T =
    2147483647;
pub type MMAL_PARAM_CAPTURE_STATUS_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAPTURE_STATUS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Capture status"]
    pub status: MMAL_PARAM_CAPTURE_STATUS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAPTURE_STATUS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAPTURE_STATUS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAPTURE_STATUS_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAPTURE_STATUS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTURE_STATUS_T),
            "::",
            stringify!(status)
        )
    );
}
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_OFF: MMAL_PARAM_FOCUS_STATUS_T = 0;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_REQUEST: MMAL_PARAM_FOCUS_STATUS_T = 1;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_REACHED: MMAL_PARAM_FOCUS_STATUS_T = 2;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_UNABLE_TO_REACH:
    MMAL_PARAM_FOCUS_STATUS_T = 3;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_LOST: MMAL_PARAM_FOCUS_STATUS_T = 4;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_MOVING: MMAL_PARAM_FOCUS_STATUS_T =
    5;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_SUCCESS: MMAL_PARAM_FOCUS_STATUS_T =
    6;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_FAILED: MMAL_PARAM_FOCUS_STATUS_T =
    7;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MANUAL_MOVING:
    MMAL_PARAM_FOCUS_STATUS_T = 8;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MANUAL_REACHED:
    MMAL_PARAM_FOCUS_STATUS_T = 9;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_WATCHING:
    MMAL_PARAM_FOCUS_STATUS_T = 10;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_CAF_SCENE_CHANGED:
    MMAL_PARAM_FOCUS_STATUS_T = 11;
pub const MMAL_PARAM_FOCUS_STATUS_T_MMAL_PARAM_FOCUS_STATUS_MAX: MMAL_PARAM_FOCUS_STATUS_T =
    2147483647;
pub type MMAL_PARAM_FOCUS_STATUS_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_STATUS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Focus status"]
    pub status: MMAL_PARAM_FOCUS_STATUS_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_STATUS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FOCUS_STATUS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_STATUS_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_STATUS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_STATUS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_STATUS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_STATUS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_STATUS_T),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "< Disables face detection"]
pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_NONE: MMAL_PARAM_FACE_TRACK_MODE_T =
    0;
#[doc = "< Enables face detection"]
pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_ON: MMAL_PARAM_FACE_TRACK_MODE_T = 1;
pub const MMAL_PARAM_FACE_TRACK_MODE_T_MMAL_PARAM_FACE_DETECT_MAX: MMAL_PARAM_FACE_TRACK_MODE_T =
    2147483647;
pub type MMAL_PARAM_FACE_TRACK_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FACE_TRACK_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_PARAM_FACE_TRACK_MODE_T,
    pub maxRegions: u32,
    pub frames: u32,
    pub quality: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FACE_TRACK_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FACE_TRACK_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FACE_TRACK_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FACE_TRACK_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FACE_TRACK_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxRegions) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(maxRegions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_T),
            "::",
            stringify!(quality)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FACE_TRACK_FACE_T {
    #[doc = "< Face ID. Should remain the same whilst the face is detected to remain in the scene"]
    pub face_id: i32,
    #[doc = "< Confidence of the face detection. Range 1-100 (1=unsure, 100=positive)."]
    pub score: i32,
    #[doc = "< Rectangle around the whole face"]
    pub face_rect: MMAL_RECT_T,
    #[doc = "< Rectangle around the eyes ([0] = left eye, [1] = right eye)"]
    pub eye_rect: [MMAL_RECT_T; 2usize],
    #[doc = "< Rectangle around the mouth"]
    pub mouth_rect: MMAL_RECT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_FACE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FACE_TRACK_FACE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FACE_TRACK_FACE_T>(),
        72usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FACE_TRACK_FACE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(face_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).score) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face_rect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(face_rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eye_rect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(eye_rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mouth_rect) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_FACE_T),
            "::",
            stringify!(mouth_rect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FACE_TRACK_RESULTS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Number of faces detected"]
    pub num_faces: u32,
    #[doc = "< Width of the frame on which the faces were detected (allows scaling)"]
    pub frame_width: u32,
    #[doc = "< Height of the frame on which the faces were detected (allows scaling)"]
    pub frame_height: u32,
    #[doc = "< Face information (variable length array"]
    pub faces: [MMAL_PARAMETER_FACE_TRACK_FACE_T; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FACE_TRACK_RESULTS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FACE_TRACK_RESULTS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>(),
        92usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FACE_TRACK_RESULTS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_faces) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(num_faces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(frame_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(frame_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).faces) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FACE_TRACK_RESULTS_T),
            "::",
            stringify!(faces)
        )
    );
}
pub mod MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T {
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "< Always timestamp frames as 0"]
    pub const MMAL_PARAM_TIMESTAMP_MODE_ZERO: Type = 0;
    #[doc = "< Use the raw STC value for the frame timestamp"]
    pub const MMAL_PARAM_TIMESTAMP_MODE_RAW_STC: Type = 1;
    #[doc = "< Use the STC timestamp but subtract the timestamp\n of the first frame sent to give a zero based timestamp."]
    pub const MMAL_PARAM_TIMESTAMP_MODE_RESET_STC: Type = 2;
    pub const MMAL_PARAM_TIMESTAMP_MODE_MAX: Type = 2147483647;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_CONFIG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Max size of stills capture"]
    pub max_stills_w: u32,
    pub max_stills_h: u32,
    #[doc = "< Allow YUV422 stills capture"]
    pub stills_yuv422: u32,
    #[doc = "< Continuous or one shot stills captures."]
    pub one_shot_stills: u32,
    #[doc = "< Max size of the preview or video capture frames"]
    pub max_preview_video_w: u32,
    pub max_preview_video_h: u32,
    pub num_preview_video_frames: u32,
    #[doc = "< Sets the height of the circular buffer for stills capture."]
    pub stills_capture_circular_buffer_height: u32,
    #[doc = "< Allows preview/encode to resume as fast as possible after the stills input frame\n has been received, and then processes the still frame in the background\n whilst preview/encode has resumed.\n Actual mode is controlled by MMAL_PARAMETER_CAPTURE_MODE."]
    pub fast_preview_resume: u32,
    pub use_stc_timestamp: MMAL_PARAMETER_CAMERA_CONFIG_TIMESTAMP_MODE_T::Type,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_CONFIG_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_CONFIG_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_CONFIG_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_CONFIG_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_stills_w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_stills_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_stills_h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_stills_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stills_yuv422) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(stills_yuv422)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).one_shot_stills) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(one_shot_stills)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_preview_video_w) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_preview_video_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_preview_video_h) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(max_preview_video_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_preview_video_frames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(num_preview_video_frames)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).stills_capture_circular_buffer_height) as usize
                - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(stills_capture_circular_buffer_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fast_preview_resume) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(fast_preview_resume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_stc_timestamp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CONFIG_T),
            "::",
            stringify!(use_stc_timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INFO_CAMERA_T {
    pub port_id: u32,
    pub max_width: u32,
    pub max_height: u32,
    pub lens_present: MMAL_BOOL_T,
    pub camera_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_CAMERA_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INFO_CAMERA_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lens_present) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(lens_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).camera_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_CAMERA_T),
            "::",
            stringify!(camera_name)
        )
    );
}
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_XENON:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 0;
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_LED:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 1;
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_OTHER:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 2;
pub const MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T_MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_MAX:
    MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = 2147483647;
pub type MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INFO_FLASH_T {
    pub flash_type: MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_FLASH_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_INFO_FLASH_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INFO_FLASH_T>(),
        4usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INFO_FLASH_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INFO_FLASH_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_FLASH_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flash_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_FLASH_T),
            "::",
            stringify!(flash_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INFO_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub num_cameras: u32,
    pub num_flashes: u32,
    pub cameras: [MMAL_PARAMETER_CAMERA_INFO_CAMERA_T; 4usize],
    pub flashes: [MMAL_PARAMETER_CAMERA_INFO_FLASH_T; 2usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INFO_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_INFO_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INFO_T>(),
        152usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INFO_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INFO_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAMERA_INFO_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_cameras) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(num_cameras)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_flashes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(num_flashes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cameras) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(cameras)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flashes) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INFO_T),
            "::",
            stringify!(flashes)
        )
    );
}
#[doc = "< Resumes preview once capture is completed."]
pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END:
    MMAL_PARAMETER_CAPTUREMODE_MODE_T = 0;
#[doc = "< Resumes preview once capture is completed, and hold the image for subsequent reprocessing."]
pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_WAIT_FOR_END_AND_HOLD:
    MMAL_PARAMETER_CAPTUREMODE_MODE_T = 1;
#[doc = "< Resumes preview as soon as possible once capture frame is received from the sensor.\n   Requires fast_preview_resume to be set via MMAL_PARAMETER_CAMERA_CONFIG."]
pub const MMAL_PARAMETER_CAPTUREMODE_MODE_T_MMAL_PARAM_CAPTUREMODE_RESUME_VF_IMMEDIATELY:
    MMAL_PARAMETER_CAPTUREMODE_MODE_T = 2;
pub type MMAL_PARAMETER_CAPTUREMODE_MODE_T = ::std::os::raw::c_uint;
#[doc = " Stills capture mode control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAPTUREMODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_PARAMETER_CAPTUREMODE_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAPTUREMODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAPTUREMODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAPTUREMODE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAPTUREMODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAPTUREMODE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CAPTUREMODE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTUREMODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAPTUREMODE_T),
            "::",
            stringify!(mode)
        )
    );
}
#[doc = "< Region defines a generic region"]
pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_NORMAL:
    MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 0;
#[doc = "< Region defines a face"]
pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_FACE:
    MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 1;
pub const MMAL_PARAMETER_FOCUS_REGION_TYPE_T_MMAL_PARAMETER_FOCUS_REGION_TYPE_MAX:
    MMAL_PARAMETER_FOCUS_REGION_TYPE_T = 2;
pub type MMAL_PARAMETER_FOCUS_REGION_TYPE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_REGION_T {
    #[doc = "< Focus rectangle as 0P16 fixed point values."]
    pub rect: MMAL_RECT_T,
    #[doc = "< Region weighting."]
    pub weight: u32,
    #[doc = "< Mask for multi-stage regions"]
    pub mask: u32,
    #[doc = "< Region type"]
    pub type_: MMAL_PARAMETER_FOCUS_REGION_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_REGION_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FOCUS_REGION_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_REGION_T>(),
        28usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_REGION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_REGION_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_REGION_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weight) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGION_T),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FOCUS_REGIONS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Number of regions defined"]
    pub num_regions: u32,
    #[doc = "< If region is within tolerance of a face, adopt face rect instead of defined region"]
    pub lock_to_faces: MMAL_BOOL_T,
    #[doc = "< Variable number of regions"]
    pub regions: [MMAL_PARAMETER_FOCUS_REGION_T; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FOCUS_REGIONS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FOCUS_REGIONS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FOCUS_REGIONS_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FOCUS_REGIONS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_regions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(num_regions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_to_faces) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(lock_to_faces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FOCUS_REGIONS_T),
            "::",
            stringify!(regions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_INPUT_CROP_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Crop rectangle as 16P16 fixed point values"]
    pub rect: MMAL_RECT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_INPUT_CROP_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_INPUT_CROP_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_INPUT_CROP_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_INPUT_CROP_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_INPUT_CROP_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_INPUT_CROP_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INPUT_CROP_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INPUT_CROP_T),
            "::",
            stringify!(rect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SENSOR_INFORMATION_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Lens f-number"]
    pub f_number: MMAL_RATIONAL_T,
    #[doc = "< Lens focal length"]
    pub focal_length: MMAL_RATIONAL_T,
    #[doc = "< Sensor reported model id"]
    pub model_id: u32,
    #[doc = "< Sensor reported manufacturer id"]
    pub manufacturer_id: u32,
    #[doc = "< Sensor reported revision"]
    pub revision: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SENSOR_INFORMATION_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_SENSOR_INFORMATION_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SENSOR_INFORMATION_T>(),
        36usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SENSOR_INFORMATION_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(f_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focal_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(focal_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).model_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(model_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manufacturer_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(manufacturer_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SENSOR_INFORMATION_T),
            "::",
            stringify!(revision)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FLASH_SELECT_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Flash type to use"]
    pub flash_type: MMAL_PARAMETER_CAMERA_INFO_FLASH_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FLASH_SELECT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FLASH_SELECT_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FLASH_SELECT_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FLASH_SELECT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FLASH_SELECT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FLASH_SELECT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_SELECT_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flash_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FLASH_SELECT_T),
            "::",
            stringify!(flash_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FIELD_OF_VIEW_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Horizontal field of view"]
    pub fov_h: MMAL_RATIONAL_T,
    #[doc = "< Vertical field of view"]
    pub fov_v: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FIELD_OF_VIEW_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FIELD_OF_VIEW_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FIELD_OF_VIEW_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FIELD_OF_VIEW_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fov_h) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T),
            "::",
            stringify!(fov_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fov_v) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FIELD_OF_VIEW_T),
            "::",
            stringify!(fov_v)
        )
    );
}
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_OFF:
    MMAL_PARAMETER_DRC_STRENGTH_T = 0;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_LOW:
    MMAL_PARAMETER_DRC_STRENGTH_T = 1;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_MEDIUM:
    MMAL_PARAMETER_DRC_STRENGTH_T = 2;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_HIGH:
    MMAL_PARAMETER_DRC_STRENGTH_T = 3;
pub const MMAL_PARAMETER_DRC_STRENGTH_T_MMAL_PARAMETER_DRC_STRENGTH_MAX:
    MMAL_PARAMETER_DRC_STRENGTH_T = 2147483647;
pub type MMAL_PARAMETER_DRC_STRENGTH_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_DRC_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< DRC strength"]
    pub strength: MMAL_PARAMETER_DRC_STRENGTH_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_DRC_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_DRC_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_DRC_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_DRC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_DRC_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_DRC_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DRC_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DRC_T),
            "::",
            stringify!(strength)
        )
    );
}
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACETRACKING : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 0 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_REDEYE_REDUCTION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 1 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_STABILISATION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 2 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_WRITE_RAW : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 3 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_VIDEO_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 4 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_STILLS_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 5 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_TEMPORAL_DENOISE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 6 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_ANTISHAKE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 7 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_IMAGE_EFFECTS : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 8 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_DYNAMIC_RANGE_COMPRESSION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 9 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_RECOGNITION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 10 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_FACE_BEAUTIFICATION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 11 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_SCENE_DETECTION : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 12 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_HIGH_DYNAMIC_RANGE : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 13 ;
pub const MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T_MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_MAX : MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = 2147483647 ;
pub type MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_ALGORITHM_CONTROL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub algorithm: MMAL_PARAMETER_ALGORITHM_CONTROL_ALGORITHMS_T,
    pub enabled: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_ALGORITHM_CONTROL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_ALGORITHM_CONTROL_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_ALGORITHM_CONTROL_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ALGORITHM_CONTROL_T),
            "::",
            stringify!(enabled)
        )
    );
}
#[doc = "< Compromise on behaviour as use case totally unknown"]
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_UNKNOWN:
    MMAL_PARAM_CAMERA_USE_CASE_T = 0;
#[doc = "< Stills capture use case"]
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_STILLS_CAPTURE:
    MMAL_PARAM_CAMERA_USE_CASE_T = 1;
#[doc = "< Video encode (camcorder) use case"]
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_VIDEO_CAPTURE:
    MMAL_PARAM_CAMERA_USE_CASE_T = 2;
pub const MMAL_PARAM_CAMERA_USE_CASE_T_MMAL_PARAM_CAMERA_USE_CASE_MAX:
    MMAL_PARAM_CAMERA_USE_CASE_T = 2147483647;
pub type MMAL_PARAM_CAMERA_USE_CASE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_USE_CASE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Use case"]
    pub use_case: MMAL_PARAM_CAMERA_USE_CASE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_USE_CASE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_USE_CASE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_USE_CASE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_USE_CASE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_case) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_USE_CASE_T),
            "::",
            stringify!(use_case)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FPS_RANGE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Low end of the permitted framerate range"]
    pub fps_low: MMAL_RATIONAL_T,
    #[doc = "< High end of the permitted framerate range"]
    pub fps_high: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FPS_RANGE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FPS_RANGE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FPS_RANGE_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FPS_RANGE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FPS_RANGE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FPS_RANGE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FPS_RANGE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_low) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FPS_RANGE_T),
            "::",
            stringify!(fps_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_high) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FPS_RANGE_T),
            "::",
            stringify!(fps_high)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_ZEROSHUTTERLAG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Select zero shutter lag mode from sensor"]
    pub zero_shutter_lag_mode: MMAL_BOOL_T,
    #[doc = "< Activate full zero shutter lag mode and\n  use the last preview raw image for the stills capture"]
    pub concurrent_capture: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_ZEROSHUTTERLAG_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_ZEROSHUTTERLAG_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_ZEROSHUTTERLAG_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_shutter_lag_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T),
            "::",
            stringify!(zero_shutter_lag_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrent_capture) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ZEROSHUTTERLAG_T),
            "::",
            stringify!(concurrent_capture)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_AWB_GAINS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Red gain"]
    pub r_gain: MMAL_RATIONAL_T,
    #[doc = "< Blue gain"]
    pub b_gain: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_AWB_GAINS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_AWB_GAINS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_AWB_GAINS_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_AWB_GAINS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_AWB_GAINS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_AWB_GAINS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWB_GAINS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_gain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWB_GAINS_T),
            "::",
            stringify!(r_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_gain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AWB_GAINS_T),
            "::",
            stringify!(b_gain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_SETTINGS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub exposure: u32,
    pub analog_gain: MMAL_RATIONAL_T,
    pub digital_gain: MMAL_RATIONAL_T,
    pub awb_red_gain: MMAL_RATIONAL_T,
    pub awb_blue_gain: MMAL_RATIONAL_T,
    pub focus_position: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_SETTINGS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_SETTINGS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_SETTINGS_T>(),
        48usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_SETTINGS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exposure) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analog_gain) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(analog_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digital_gain) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(digital_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_red_gain) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(awb_red_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_blue_gain) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(awb_blue_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_position) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_SETTINGS_T),
            "::",
            stringify!(focus_position)
        )
    );
}
#[doc = "< Indicator will be off."]
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_OFF:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 0;
#[doc = "< Indicator will come on just after a stills capture and\n   and remain on for 2seconds, or will be on whilst output[1]\n   is actively producing images."]
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_ON:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 1;
#[doc = "< Turns indicator of for 2s independent of capture status.\n   Set this mode repeatedly to keep the indicator on for a\n   longer period."]
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_FORCE_ON:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 2;
pub const MMAL_PARAM_PRIVACY_INDICATOR_T_MMAL_PARAMETER_PRIVACY_INDICATOR_MAX:
    MMAL_PARAM_PRIVACY_INDICATOR_T = 2147483647;
pub type MMAL_PARAM_PRIVACY_INDICATOR_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_PRIVACY_INDICATOR_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_PARAM_PRIVACY_INDICATOR_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_PRIVACY_INDICATOR_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_PRIVACY_INDICATOR_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_PRIVACY_INDICATOR_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_PRIVACY_INDICATOR_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_PRIVACY_INDICATOR_T),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub text: [::std::os::raw::c_char; 32usize],
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_ANNOTATE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>(),
        64usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_shutter) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_analog_gain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_lens) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_caf) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_motion) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_T),
            "::",
            stringify!(show_motion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
    pub show_frame_num: MMAL_BOOL_T,
    pub black_text_background: MMAL_BOOL_T,
    pub text: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>(),
        296usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_shutter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_analog_gain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_lens) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_caf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_motion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_frame_num) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(show_frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_text_background) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(black_text_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V2_T),
            "::",
            stringify!(text)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
    pub show_frame_num: MMAL_BOOL_T,
    pub enable_text_background: MMAL_BOOL_T,
    pub custom_background_colour: MMAL_BOOL_T,
    pub custom_background_Y: u8,
    pub custom_background_U: u8,
    pub custom_background_V: u8,
    pub dummy1: u8,
    pub custom_text_colour: MMAL_BOOL_T,
    pub custom_text_Y: u8,
    pub custom_text_U: u8,
    pub custom_text_V: u8,
    pub text_size: u8,
    pub text: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>(),
        312usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_shutter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_analog_gain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_lens) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_caf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_motion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_frame_num) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(show_frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_text_background) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(enable_text_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_colour) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_colour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_Y) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_U) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_V) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_background_V)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_colour) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_colour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_Y) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_U) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_V) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(custom_text_V)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_size) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V3_T),
            "::",
            stringify!(text)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: MMAL_BOOL_T,
    pub show_shutter: MMAL_BOOL_T,
    pub show_analog_gain: MMAL_BOOL_T,
    pub show_lens: MMAL_BOOL_T,
    pub show_caf: MMAL_BOOL_T,
    pub show_motion: MMAL_BOOL_T,
    pub show_frame_num: MMAL_BOOL_T,
    pub enable_text_background: MMAL_BOOL_T,
    pub custom_background_colour: MMAL_BOOL_T,
    pub custom_background_Y: u8,
    pub custom_background_U: u8,
    pub custom_background_V: u8,
    pub dummy1: u8,
    pub custom_text_colour: MMAL_BOOL_T,
    pub custom_text_Y: u8,
    pub custom_text_U: u8,
    pub custom_text_V: u8,
    pub text_size: u8,
    pub text: [::std::os::raw::c_char; 256usize],
    pub justify: u32,
    pub x_offset: u32,
    pub y_offset: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>(),
        324usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_shutter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_shutter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_analog_gain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_analog_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_lens) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_lens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_caf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_caf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_motion) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_frame_num) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(show_frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_text_background) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(enable_text_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_colour) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_colour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_Y) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_U) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_background_V) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_background_V)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_colour) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_colour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_Y) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_Y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_U) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_U)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_text_V) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(custom_text_V)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_size) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).justify) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(justify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_ANNOTATE_V4_T),
            "::",
            stringify!(y_offset)
        )
    );
}
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_NONE: MMAL_STEREOSCOPIC_MODE_T = 0;
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_SIDE_BY_SIDE: MMAL_STEREOSCOPIC_MODE_T =
    1;
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_TOP_BOTTOM: MMAL_STEREOSCOPIC_MODE_T = 2;
pub const MMAL_STEREOSCOPIC_MODE_T_MMAL_STEREOSCOPIC_MODE_MAX: MMAL_STEREOSCOPIC_MODE_T =
    2147483647;
pub type MMAL_STEREOSCOPIC_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_STEREOSCOPIC_MODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_STEREOSCOPIC_MODE_T,
    pub decimate: MMAL_BOOL_T,
    pub swap_eyes: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_STEREOSCOPIC_MODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_STEREOSCOPIC_MODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_STEREOSCOPIC_MODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(decimate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swap_eyes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STEREOSCOPIC_MODE_T),
            "::",
            stringify!(swap_eyes)
        )
    );
}
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CSI2: MMAL_CAMERA_INTERFACE_T = 0;
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CCP2: MMAL_CAMERA_INTERFACE_T = 1;
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_CPI: MMAL_CAMERA_INTERFACE_T = 2;
pub const MMAL_CAMERA_INTERFACE_T_MMAL_CAMERA_INTERFACE_MAX: MMAL_CAMERA_INTERFACE_T = 2147483647;
pub type MMAL_CAMERA_INTERFACE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_INTERFACE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_CAMERA_INTERFACE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_INTERFACE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_INTERFACE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_INTERFACE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_INTERFACE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_INTERFACE_T),
            "::",
            stringify!(mode)
        )
    );
}
pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_STROBE:
    MMAL_CAMERA_CLOCKING_MODE_T = 0;
pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_CLOCK: MMAL_CAMERA_CLOCKING_MODE_T =
    1;
pub const MMAL_CAMERA_CLOCKING_MODE_T_MMAL_CAMERA_CLOCKING_MODE_MAX: MMAL_CAMERA_CLOCKING_MODE_T =
    2147483647;
pub type MMAL_CAMERA_CLOCKING_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_CAMERA_CLOCKING_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_CLOCKING_MODE_T),
            "::",
            stringify!(mode)
        )
    );
}
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_NONE:
    MMAL_CAMERA_RX_CONFIG_DECODE = 0;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO10:
    MMAL_CAMERA_RX_CONFIG_DECODE = 1;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO10:
    MMAL_CAMERA_RX_CONFIG_DECODE = 2;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO10:
    MMAL_CAMERA_RX_CONFIG_DECODE = 3;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO12:
    MMAL_CAMERA_RX_CONFIG_DECODE = 4;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM7TO12:
    MMAL_CAMERA_RX_CONFIG_DECODE = 5;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM6TO12:
    MMAL_CAMERA_RX_CONFIG_DECODE = 6;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO14:
    MMAL_CAMERA_RX_CONFIG_DECODE = 7;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO14:
    MMAL_CAMERA_RX_CONFIG_DECODE = 8;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM12TO16:
    MMAL_CAMERA_RX_CONFIG_DECODE = 9;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM10TO16:
    MMAL_CAMERA_RX_CONFIG_DECODE = 10;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_DPCM8TO16:
    MMAL_CAMERA_RX_CONFIG_DECODE = 11;
pub const MMAL_CAMERA_RX_CONFIG_DECODE_MMAL_CAMERA_RX_CONFIG_DECODE_MAX:
    MMAL_CAMERA_RX_CONFIG_DECODE = 2147483647;
pub type MMAL_CAMERA_RX_CONFIG_DECODE = ::std::os::raw::c_uint;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_NONE:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 0;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM10TO8:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 1;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM12TO8:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 2;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_DPCM14TO8:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 3;
pub const MMAL_CAMERA_RX_CONFIG_ENCODE_MMAL_CAMERA_RX_CONFIG_ENCODE_MAX:
    MMAL_CAMERA_RX_CONFIG_ENCODE = 2147483647;
pub type MMAL_CAMERA_RX_CONFIG_ENCODE = ::std::os::raw::c_uint;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_NONE:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 0;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_6:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 1;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_7:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 2;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_8:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 3;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_10:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 4;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_12:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 5;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_14:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 6;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_16:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 7;
pub const MMAL_CAMERA_RX_CONFIG_UNPACK_MMAL_CAMERA_RX_CONFIG_UNPACK_MAX:
    MMAL_CAMERA_RX_CONFIG_UNPACK = 2147483647;
pub type MMAL_CAMERA_RX_CONFIG_UNPACK = ::std::os::raw::c_uint;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_NONE: MMAL_CAMERA_RX_CONFIG_PACK =
    0;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_8: MMAL_CAMERA_RX_CONFIG_PACK = 1;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_10: MMAL_CAMERA_RX_CONFIG_PACK = 2;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_12: MMAL_CAMERA_RX_CONFIG_PACK = 3;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_14: MMAL_CAMERA_RX_CONFIG_PACK = 4;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_16: MMAL_CAMERA_RX_CONFIG_PACK = 5;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_RAW10: MMAL_CAMERA_RX_CONFIG_PACK =
    6;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_RAW12: MMAL_CAMERA_RX_CONFIG_PACK =
    7;
pub const MMAL_CAMERA_RX_CONFIG_PACK_MMAL_CAMERA_RX_CONFIG_PACK_MAX: MMAL_CAMERA_RX_CONFIG_PACK =
    2147483647;
pub type MMAL_CAMERA_RX_CONFIG_PACK = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_RX_CONFIG_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub decode: MMAL_CAMERA_RX_CONFIG_DECODE,
    pub encode: MMAL_CAMERA_RX_CONFIG_ENCODE,
    pub unpack: MMAL_CAMERA_RX_CONFIG_UNPACK,
    pub pack: MMAL_CAMERA_RX_CONFIG_PACK,
    pub data_lanes: u32,
    pub encode_block_length: u32,
    pub embedded_data_lines: u32,
    pub image_id: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_RX_CONFIG_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_RX_CONFIG_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_RX_CONFIG_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(encode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unpack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(unpack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pack) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(pack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_lanes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(data_lanes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encode_block_length) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(encode_block_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).embedded_data_lines) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(embedded_data_lines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_CONFIG_T),
            "::",
            stringify!(image_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CAMERA_RX_TIMING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub timing1: u32,
    pub timing2: u32,
    pub timing3: u32,
    pub timing4: u32,
    pub timing5: u32,
    pub term1: u32,
    pub term2: u32,
    pub cpi_timing1: u32,
    pub cpi_timing2: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CAMERA_RX_TIMING_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CAMERA_RX_TIMING_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CAMERA_RX_TIMING_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing5) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(timing5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(term1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).term2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(term2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpi_timing1) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(cpi_timing1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpi_timing2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CAMERA_RX_TIMING_T),
            "::",
            stringify!(cpi_timing2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_LENS_SHADING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enabled: MMAL_BOOL_T,
    pub grid_cell_size: u32,
    pub grid_width: u32,
    pub grid_stride: u32,
    pub grid_height: u32,
    pub mem_handle_table: u32,
    pub ref_transform: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_LENS_SHADING_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_LENS_SHADING_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_LENS_SHADING_T>(),
        36usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_LENS_SHADING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_LENS_SHADING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_LENS_SHADING_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_cell_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_cell_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_stride) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(grid_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_handle_table) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(mem_handle_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_transform) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_T),
            "::",
            stringify!(ref_transform)
        )
    );
}
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U0P8_1:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 0;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U1P7_0:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 1;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U1P7_1:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 2;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U2P6_0:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 3;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U2P6_1:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 4;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U3P5_0:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 5;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U3P5_1:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 6;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_U4P10:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 7;
pub const MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T_MMAL_PARAM_LS_GAIN_FORMAT_TYPE_DUMMY:
    MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = 2147483647;
pub type MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_LENS_SHADING_V2_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enabled: MMAL_BOOL_T,
    pub grid_cell_size: u32,
    pub grid_width: u32,
    pub grid_stride: u32,
    pub grid_height: u32,
    pub mem_handle_table: u32,
    pub ref_transform: u32,
    pub corner_sampled: MMAL_BOOL_T,
    pub gain_format: MMAL_PARAM_LS_GAIN_FORMAT_TYPE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_LENS_SHADING_V2_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_LENS_SHADING_V2_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_LENS_SHADING_V2_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_LENS_SHADING_V2_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_cell_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(grid_cell_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(grid_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_stride) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(grid_stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grid_height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(grid_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_handle_table) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(mem_handle_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_transform) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(ref_transform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corner_sampled) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(corner_sampled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gain_format) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_LENS_SHADING_V2_T),
            "::",
            stringify!(gain_format)
        )
    );
}
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_NONE: MMAL_RESIZEMODE_T = 0;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_CROP: MMAL_RESIZEMODE_T = 1;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_BOX: MMAL_RESIZEMODE_T = 2;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_BYTES: MMAL_RESIZEMODE_T = 3;
pub const MMAL_RESIZEMODE_T_MMAL_RESIZE_DUMMY: MMAL_RESIZEMODE_T = 2147483647;
pub type MMAL_RESIZEMODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_RESIZE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mode: MMAL_RESIZEMODE_T,
    pub max_width: u32,
    pub max_height: u32,
    pub max_bytes: u32,
    pub preserve_aspect_ratio: MMAL_BOOL_T,
    pub allow_upscaling: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_RESIZE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_RESIZE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_RESIZE_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_RESIZE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_RESIZE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_RESIZE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bytes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(max_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preserve_aspect_ratio) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(preserve_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_upscaling) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RESIZE_T),
            "::",
            stringify!(allow_upscaling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CROP_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub rect: MMAL_RECT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CROP_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CROP_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CROP_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CROP_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CROP_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CROP_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CROP_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CROP_T),
            "::",
            stringify!(rect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CCM_T {
    pub ccm: [[MMAL_RATIONAL_T; 3usize]; 3usize],
    pub offsets: [i32; 3usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CCM_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CCM_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CCM_T>(),
        84usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CCM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CCM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CCM_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ccm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CCM_T),
            "::",
            stringify!(ccm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsets) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CCM_T),
            "::",
            stringify!(offsets)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CUSTOM_CCM_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable the custom CCM."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< CCM to be used."]
    pub ccm: MMAL_PARAMETER_CCM_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CUSTOM_CCM_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CUSTOM_CCM_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CUSTOM_CCM_T>(),
        96usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CUSTOM_CCM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CUSTOM_CCM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CUSTOM_CCM_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CUSTOM_CCM_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CUSTOM_CCM_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ccm) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CUSTOM_CCM_T),
            "::",
            stringify!(ccm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BLACK_LEVEL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable denoise parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< Black level of red channel (out of 16 bits)."]
    pub black_level_r: u16,
    #[doc = "< Black level of green channel (out of 16 bits)."]
    pub black_level_g: u16,
    #[doc = "< Black level of blue channel (out of 16 bits)."]
    pub black_level_b: u16,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BLACK_LEVEL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_BLACK_LEVEL_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BLACK_LEVEL_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_BLACK_LEVEL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BLACK_LEVEL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_BLACK_LEVEL_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BLACK_LEVEL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BLACK_LEVEL_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_r) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BLACK_LEVEL_T),
            "::",
            stringify!(black_level_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_g) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BLACK_LEVEL_T),
            "::",
            stringify!(black_level_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BLACK_LEVEL_T),
            "::",
            stringify!(black_level_b)
        )
    );
}
pub const MMAL_PARAM_CDN_MODE_T_MMAL_PARAM_CDN_FAST: MMAL_PARAM_CDN_MODE_T = 0;
pub const MMAL_PARAM_CDN_MODE_T_MMAL_PARAM_CDN_HIGH_QUALITY: MMAL_PARAM_CDN_MODE_T = 1;
pub const MMAL_PARAM_CDN_MODE_T_MMAL_PARAM_CDN_DUMMY: MMAL_PARAM_CDN_MODE_T = 2147483647;
pub type MMAL_PARAM_CDN_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CDN_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable colour denoise parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< Colour denoise mode of operation."]
    pub mode: MMAL_PARAM_CDN_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CDN_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CDN_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CDN_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CDN_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CDN_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CDN_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CDN_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CDN_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CDN_T),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_DENOISE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable denoise parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< Constant offset of the noise profile."]
    pub constant: u32,
    #[doc = "< Slope of the noise profile."]
    pub slope: MMAL_RATIONAL_T,
    #[doc = "< Denoise strength."]
    pub strength: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_DENOISE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_DENOISE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_DENOISE_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_DENOISE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_DENOISE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_DENOISE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DENOISE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DENOISE_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DENOISE_T),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slope) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DENOISE_T),
            "::",
            stringify!(slope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DENOISE_T),
            "::",
            stringify!(strength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SHARPEN_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable sharpening parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< Threshold when sharpening starts."]
    pub threshold: MMAL_RATIONAL_T,
    #[doc = "< Rate at which sharpening ramps."]
    pub strength: MMAL_RATIONAL_T,
    #[doc = "< Limit to total sharpening."]
    pub limit: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SHARPEN_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_SHARPEN_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SHARPEN_T>(),
        36usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SHARPEN_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SHARPEN_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_SHARPEN_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SHARPEN_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SHARPEN_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SHARPEN_T),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strength) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SHARPEN_T),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SHARPEN_T),
            "::",
            stringify!(limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_GREEN_EQ_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable Green Equalisation parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< Offset of Green Equalisation threshold."]
    pub offset: u32,
    #[doc = "< Rate at which Green Equalisation threshold ramps."]
    pub slope: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_GREEN_EQ_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_GREEN_EQ_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_GREEN_EQ_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_GREEN_EQ_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_GREEN_EQ_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_GREEN_EQ_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GREEN_EQ_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GREEN_EQ_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GREEN_EQ_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slope) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GREEN_EQ_T),
            "::",
            stringify!(slope)
        )
    );
}
pub const MMAL_DPC_MODE_T_MMAL_DPC_MODE_OFF: MMAL_DPC_MODE_T = 0;
pub const MMAL_DPC_MODE_T_MMAL_DPC_MODE_NORMAL: MMAL_DPC_MODE_T = 1;
pub const MMAL_DPC_MODE_T_MMAL_DPC_MODE_STRONG: MMAL_DPC_MODE_T = 2;
pub const MMAL_DPC_MODE_T_MMAL_DPC_MODE_MAX: MMAL_DPC_MODE_T = 2147483647;
pub type MMAL_DPC_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_DPC_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable DPC parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< DPC strength."]
    pub strength: MMAL_DPC_MODE_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_DPC_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_DPC_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_DPC_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_DPC_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_DPC_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_DPC_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DPC_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DPC_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_DPC_T),
            "::",
            stringify!(strength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_GAMMA_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Enable gamma parameters."]
    pub enable: MMAL_BOOL_T,
    #[doc = "< X values (16 bit range)"]
    pub X: [u16; 33usize],
    #[doc = "< Y values (16 bit range)"]
    pub Y: [u16; 33usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_GAMMA_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_GAMMA_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_GAMMA_T>(),
        144usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_GAMMA_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_GAMMA_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_GAMMA_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GAMMA_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GAMMA_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GAMMA_T),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Y) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_GAMMA_T),
            "::",
            stringify!(Y)
        )
    );
}
#[doc = "< Takes a @ref MMAL_DISPLAYREGION_T"]
pub const MMAL_PARAMETER_DISPLAYREGION: _bindgen_ty_25 = 131072;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T"]
pub const MMAL_PARAMETER_SUPPORTED_PROFILES: _bindgen_ty_25 = 131073;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_PROFILE_T"]
pub const MMAL_PARAMETER_PROFILE: _bindgen_ty_25 = 131074;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_INTRAPERIOD: _bindgen_ty_25 = 131075;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_RATECONTROL_T"]
pub const MMAL_PARAMETER_RATECONTROL: _bindgen_ty_25 = 131076;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T"]
pub const MMAL_PARAMETER_NALUNITFORMAT: _bindgen_ty_25 = 131077;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_MINIMISE_FRAGMENTATION: _bindgen_ty_25 = 131078;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T.\n Setting the value to zero resets to the default (one slice per frame)."]
pub const MMAL_PARAMETER_MB_ROWS_PER_SLICE: _bindgen_ty_25 = 131079;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T"]
pub const MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION: _bindgen_ty_25 = 131080;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T"]
pub const MMAL_PARAMETER_VIDEO_EEDE_ENABLE: _bindgen_ty_25 = 131081;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T"]
pub const MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE: _bindgen_ty_25 = 131082;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T.\n Request an I-frame."]
pub const MMAL_PARAMETER_VIDEO_REQUEST_I_FRAME: _bindgen_ty_25 = 131083;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T"]
pub const MMAL_PARAMETER_VIDEO_INTRA_REFRESH: _bindgen_ty_25 = 131084;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_IMMUTABLE_INPUT: _bindgen_ty_25 = 131085;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T.\n Run-time bit rate control"]
pub const MMAL_PARAMETER_VIDEO_BIT_RATE: _bindgen_ty_25 = 131086;
#[doc = "< Takes a @ref MMAL_PARAMETER_FRAME_RATE_T"]
pub const MMAL_PARAMETER_VIDEO_FRAME_RATE: _bindgen_ty_25 = 131087;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_MIN_QUANT: _bindgen_ty_25 = 131088;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_MAX_QUANT: _bindgen_ty_25 = 131089;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL: _bindgen_ty_25 = 131090;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_EXTRA_BUFFERS: _bindgen_ty_25 = 131091;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T.\nChanging this paramater from the default can reduce frame rate\nbecause image buffers need to be re-pitched."]
pub const MMAL_PARAMETER_VIDEO_ALIGN_HORIZ: _bindgen_ty_25 = 131092;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T.\nChanging this paramater from the default can reduce frame rate\nbecause image buffers need to be re-pitched."]
pub const MMAL_PARAMETER_VIDEO_ALIGN_VERT: _bindgen_ty_25 = 131093;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAMES: _bindgen_ty_25 = 131094;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_INITIAL_QUANT: _bindgen_ty_25 = 131095;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_QP_P: _bindgen_ty_25 = 131096;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_RC_SLICE_DQUANT: _bindgen_ty_25 = 131097;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_FRAME_LIMIT_BITS: _bindgen_ty_25 = 131098;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_PEAK_RATE: _bindgen_ty_25 = 131099;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_DISABLE_CABAC: _bindgen_ty_25 = 131100;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_LATENCY: _bindgen_ty_25 = 131101;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_AU_DELIMITERS: _bindgen_ty_25 = 131102;
#[doc = "< Takes a @ref MMAL_PARAMETER_UINT32_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_DEBLOCK_IDC: _bindgen_ty_25 = 131103;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_MB_INTRA_MODE: _bindgen_ty_25 = 131104;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_HEADER_ON_OPEN: _bindgen_ty_25 = 131105;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_PRECODE_FOR_QP: _bindgen_ty_25 = 131106;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T."]
pub const MMAL_PARAMETER_VIDEO_DRM_INIT_INFO: _bindgen_ty_25 = 131107;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO: _bindgen_ty_25 = 131108;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT: _bindgen_ty_25 = 131109;
#[doc = "< Takes a @ref MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T."]
pub const MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER: _bindgen_ty_25 = 131110;
#[doc = "< Takes a @ref MMAL_PARAMETER_BYTES_T"]
pub const MMAL_PARAMETER_VIDEO_DECODE_CONFIG_VD3: _bindgen_ty_25 = 131111;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_VCL_HRD_PARAMETERS: _bindgen_ty_25 = 131112;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_H264_LOW_DELAY_HRD_FLAG: _bindgen_ty_25 = 131113;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_INLINE_HEADER: _bindgen_ty_25 = 131114;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_SEI_ENABLE: _bindgen_ty_25 = 131115;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T."]
pub const MMAL_PARAMETER_VIDEO_ENCODE_INLINE_VECTORS: _bindgen_ty_25 = 131116;
#[doc = "< Take a @ref MMAL_PARAMETER_VIDEO_RENDER_STATS_T."]
pub const MMAL_PARAMETER_VIDEO_RENDER_STATS: _bindgen_ty_25 = 131117;
#[doc = "< Take a @ref MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T."]
pub const MMAL_PARAMETER_VIDEO_INTERLACE_TYPE: _bindgen_ty_25 = 131118;
#[doc = "< Takes a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS: _bindgen_ty_25 = 131119;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_SPS_TIMING: _bindgen_ty_25 = 131120;
#[doc = "< Take a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS: _bindgen_ty_25 = 131121;
#[doc = "< Take a @ref MMAL_PARAMETER_SOURCE_PATTERN_T"]
pub const MMAL_PARAMETER_VIDEO_SOURCE_PATTERN: _bindgen_ty_25 = 131122;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_SEPARATE_NAL_BUFS: _bindgen_ty_25 = 131123;
#[doc = "< Take a @ref MMAL_PARAMETER_UINT32_T"]
pub const MMAL_PARAMETER_VIDEO_DROPPABLE_PFRAME_LENGTH: _bindgen_ty_25 = 131124;
#[doc = "< Take a @ref MMAL_PARAMETER_VIDEO_STALL_T"]
pub const MMAL_PARAMETER_VIDEO_STALL_THRESHOLD: _bindgen_ty_25 = 131125;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_ENCODE_HEADERS_WITH_FRAME: _bindgen_ty_25 = 131126;
#[doc = "< Take a @ref MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_VIDEO_VALIDATE_TIMESTAMPS: _bindgen_ty_25 = 131127;
#[doc = " Video-specific MMAL parameter IDs.\n @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT0: MMAL_DISPLAYTRANSFORM_T = 0;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT0: MMAL_DISPLAYTRANSFORM_T = 1;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT180: MMAL_DISPLAYTRANSFORM_T = 2;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT180: MMAL_DISPLAYTRANSFORM_T = 3;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT90: MMAL_DISPLAYTRANSFORM_T = 4;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT270: MMAL_DISPLAYTRANSFORM_T = 5;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_ROT90: MMAL_DISPLAYTRANSFORM_T = 6;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_MIRROR_ROT270: MMAL_DISPLAYTRANSFORM_T = 7;
pub const MMAL_DISPLAYTRANSFORM_T_MMAL_DISPLAY_DUMMY: MMAL_DISPLAYTRANSFORM_T = 2147483647;
#[doc = " Display transformations.\n Although an enumeration, the values correspond to combinations of:\n \\li 1 Reflect in a vertical axis\n \\li 2 180 degree rotation\n \\li 4 Reflect in the leading diagonal"]
pub type MMAL_DISPLAYTRANSFORM_T = ::std::os::raw::c_uint;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_FILL: MMAL_DISPLAYMODE_T = 0;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_LETTERBOX: MMAL_DISPLAYMODE_T = 1;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT: MMAL_DISPLAYMODE_T = 2;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP: MMAL_DISPLAYMODE_T = 3;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP: MMAL_DISPLAYMODE_T = 4;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT: MMAL_DISPLAYMODE_T = 5;
pub const MMAL_DISPLAYMODE_T_MMAL_DISPLAY_MODE_DUMMY: MMAL_DISPLAYMODE_T = 2147483647;
#[doc = " Display modes."]
pub type MMAL_DISPLAYMODE_T = ::std::os::raw::c_uint;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NONE: MMAL_DISPLAYSET_T = 0;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NUM: MMAL_DISPLAYSET_T = 1;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_FULLSCREEN: MMAL_DISPLAYSET_T = 2;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_TRANSFORM: MMAL_DISPLAYSET_T = 4;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_DEST_RECT: MMAL_DISPLAYSET_T = 8;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_SRC_RECT: MMAL_DISPLAYSET_T = 16;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_MODE: MMAL_DISPLAYSET_T = 32;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_PIXEL: MMAL_DISPLAYSET_T = 64;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_NOASPECT: MMAL_DISPLAYSET_T = 128;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_LAYER: MMAL_DISPLAYSET_T = 256;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_COPYPROTECT: MMAL_DISPLAYSET_T = 512;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_ALPHA: MMAL_DISPLAYSET_T = 1024;
pub const MMAL_DISPLAYSET_T_MMAL_DISPLAY_SET_DUMMY: MMAL_DISPLAYSET_T = 2147483647;
#[doc = " Values used to indicate which fields are used when setting the\n display configuration"]
pub type MMAL_DISPLAYSET_T = ::std::os::raw::c_uint;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_NONE: MMAL_DISPLAYALPHAFLAGS_T = 0;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_DISCARD_LOWER_LAYERS:
    MMAL_DISPLAYALPHAFLAGS_T = 536870912;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_PREMULT: MMAL_DISPLAYALPHAFLAGS_T =
    1073741824;
pub const MMAL_DISPLAYALPHAFLAGS_T_MMAL_DISPLAY_ALPHA_FLAGS_MIX: MMAL_DISPLAYALPHAFLAGS_T =
    -2147483648;
pub type MMAL_DISPLAYALPHAFLAGS_T = ::std::os::raw::c_int;
#[doc = "This config sets the output display device, as well as the region used\non the output display, any display transformation, and some flags to\nindicate how to scale the image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_DISPLAYREGION_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = " Bitfield that indicates which fields are set and should be used. All\n other fields will maintain their current value.\n \\ref MMAL_DISPLAYSET_T defines the bits that can be combined."]
    pub set: u32,
    #[doc = " Describes the display output device, with 0 typically being a directly\n connected LCD display.  The actual values will depend on the hardware.\n Code using hard-wired numbers (e.g. 2) is certain to fail."]
    pub display_num: u32,
    #[doc = " Indicates that we are using the full device screen area, rather than\n a window of the display.  If zero, then dest_rect is used to specify a\n region of the display to use."]
    pub fullscreen: MMAL_BOOL_T,
    #[doc = " Indicates any rotation or flipping used to map frames onto the natural\n display orientation."]
    pub transform: MMAL_DISPLAYTRANSFORM_T,
    #[doc = " Where to display the frame within the screen, if fullscreen is zero."]
    pub dest_rect: MMAL_RECT_T,
    #[doc = " Indicates which area of the frame to display. If all values are zero,\n the whole frame will be used."]
    pub src_rect: MMAL_RECT_T,
    #[doc = " If set to non-zero, indicates that any display scaling should disregard\n the aspect ratio of the frame region being displayed."]
    pub noaspect: MMAL_BOOL_T,
    #[doc = " Indicates how the image should be scaled to fit the display. \\code\n MMAL_DISPLAY_MODE_FILL \\endcode indicates that the image should fill the\n screen by potentially cropping the frames.  Setting \\code mode \\endcode\n to \\code MMAL_DISPLAY_MODE_LETTERBOX \\endcode indicates that all the source\n region should be displayed and black bars added if necessary."]
    pub mode: MMAL_DISPLAYMODE_T,
    #[doc = " If non-zero, defines the width of a source pixel relative to \\code pixel_y\n \\endcode.  If zero, then pixels default to being square."]
    pub pixel_x: u32,
    #[doc = " If non-zero, defines the height of a source pixel relative to \\code pixel_x\n \\endcode.  If zero, then pixels default to being square."]
    pub pixel_y: u32,
    #[doc = " Sets the relative depth of the images, with greater values being in front\n of smaller values."]
    pub layer: i32,
    #[doc = " Set to non-zero to ensure copy protection is used on output."]
    pub copyprotect_required: MMAL_BOOL_T,
    #[doc = " Bits 7-0: Level of opacity of the layer, where zero is fully transparent and\n 255 is fully opaque.\n Bits 31-8: Flags from \\code MMAL_DISPLAYALPHAFLAGS_T for alpha mode selection."]
    pub alpha: u32,
}
#[test]
fn bindgen_test_layout_MMAL_DISPLAYREGION_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_DISPLAYREGION_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_DISPLAYREGION_T>(),
        84usize,
        concat!("Size of: ", stringify!(MMAL_DISPLAYREGION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_DISPLAYREGION_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_DISPLAYREGION_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(display_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullscreen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(fullscreen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest_rect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(dest_rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_rect) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(src_rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noaspect) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(noaspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_x) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(pixel_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_y) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(pixel_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyprotect_required) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(copyprotect_required)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_DISPLAYREGION_T),
            "::",
            stringify!(alpha)
        )
    );
}
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_BASELINE: MMAL_VIDEO_PROFILE_T = 0;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_H320CODING: MMAL_VIDEO_PROFILE_T = 1;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_BACKWARDCOMPATIBLE: MMAL_VIDEO_PROFILE_T = 2;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_ISWV2: MMAL_VIDEO_PROFILE_T = 3;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_ISWV3: MMAL_VIDEO_PROFILE_T = 4;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_HIGHCOMPRESSION: MMAL_VIDEO_PROFILE_T = 5;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_INTERNET: MMAL_VIDEO_PROFILE_T = 6;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_INTERLACE: MMAL_VIDEO_PROFILE_T = 7;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H263_HIGHLATENCY: MMAL_VIDEO_PROFILE_T = 8;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLE: MMAL_VIDEO_PROFILE_T = 9;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLESCALABLE: MMAL_VIDEO_PROFILE_T = 10;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_CORE: MMAL_VIDEO_PROFILE_T = 11;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_MAIN: MMAL_VIDEO_PROFILE_T = 12;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_NBIT: MMAL_VIDEO_PROFILE_T = 13;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SCALABLETEXTURE: MMAL_VIDEO_PROFILE_T = 14;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLEFACE: MMAL_VIDEO_PROFILE_T = 15;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_SIMPLEFBA: MMAL_VIDEO_PROFILE_T = 16;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_BASICANIMATED: MMAL_VIDEO_PROFILE_T = 17;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_HYBRID: MMAL_VIDEO_PROFILE_T = 18;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDREALTIME: MMAL_VIDEO_PROFILE_T = 19;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_CORESCALABLE: MMAL_VIDEO_PROFILE_T = 20;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCODING: MMAL_VIDEO_PROFILE_T = 21;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDCORE: MMAL_VIDEO_PROFILE_T = 22;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSCALABLE: MMAL_VIDEO_PROFILE_T = 23;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_MP4V_ADVANCEDSIMPLE: MMAL_VIDEO_PROFILE_T = 24;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_BASELINE: MMAL_VIDEO_PROFILE_T = 25;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_MAIN: MMAL_VIDEO_PROFILE_T = 26;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_EXTENDED: MMAL_VIDEO_PROFILE_T = 27;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH: MMAL_VIDEO_PROFILE_T = 28;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH10: MMAL_VIDEO_PROFILE_T = 29;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH422: MMAL_VIDEO_PROFILE_T = 30;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_HIGH444: MMAL_VIDEO_PROFILE_T = 31;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_H264_CONSTRAINED_BASELINE: MMAL_VIDEO_PROFILE_T =
    32;
pub const MMAL_VIDEO_PROFILE_T_MMAL_VIDEO_PROFILE_DUMMY: MMAL_VIDEO_PROFILE_T = 2147483647;
#[doc = " Video profiles.\n Only certain combinations of profile and level will be valid.\n @ref MMAL_VIDEO_LEVEL_T"]
pub type MMAL_VIDEO_PROFILE_T = ::std::os::raw::c_uint;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_10: MMAL_VIDEO_LEVEL_T = 0;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_20: MMAL_VIDEO_LEVEL_T = 1;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_30: MMAL_VIDEO_LEVEL_T = 2;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_40: MMAL_VIDEO_LEVEL_T = 3;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_45: MMAL_VIDEO_LEVEL_T = 4;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_50: MMAL_VIDEO_LEVEL_T = 5;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_60: MMAL_VIDEO_LEVEL_T = 6;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H263_70: MMAL_VIDEO_LEVEL_T = 7;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_0: MMAL_VIDEO_LEVEL_T = 8;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_0b: MMAL_VIDEO_LEVEL_T = 9;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_1: MMAL_VIDEO_LEVEL_T = 10;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_2: MMAL_VIDEO_LEVEL_T = 11;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_3: MMAL_VIDEO_LEVEL_T = 12;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_4: MMAL_VIDEO_LEVEL_T = 13;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_4a: MMAL_VIDEO_LEVEL_T = 14;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_5: MMAL_VIDEO_LEVEL_T = 15;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_MP4V_6: MMAL_VIDEO_LEVEL_T = 16;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_1: MMAL_VIDEO_LEVEL_T = 17;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_1b: MMAL_VIDEO_LEVEL_T = 18;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_11: MMAL_VIDEO_LEVEL_T = 19;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_12: MMAL_VIDEO_LEVEL_T = 20;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_13: MMAL_VIDEO_LEVEL_T = 21;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_2: MMAL_VIDEO_LEVEL_T = 22;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_21: MMAL_VIDEO_LEVEL_T = 23;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_22: MMAL_VIDEO_LEVEL_T = 24;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_3: MMAL_VIDEO_LEVEL_T = 25;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_31: MMAL_VIDEO_LEVEL_T = 26;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_32: MMAL_VIDEO_LEVEL_T = 27;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_4: MMAL_VIDEO_LEVEL_T = 28;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_41: MMAL_VIDEO_LEVEL_T = 29;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_42: MMAL_VIDEO_LEVEL_T = 30;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_5: MMAL_VIDEO_LEVEL_T = 31;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_H264_51: MMAL_VIDEO_LEVEL_T = 32;
pub const MMAL_VIDEO_LEVEL_T_MMAL_VIDEO_LEVEL_DUMMY: MMAL_VIDEO_LEVEL_T = 2147483647;
#[doc = " Video levels.\n Only certain combinations of profile and level will be valid.\n @ref MMAL_VIDEO_PROFILE_T"]
pub type MMAL_VIDEO_LEVEL_T = ::std::os::raw::c_uint;
#[doc = " Video profile and level setting.\n This is a variable length structure when querying the supported profiles and\n levels. To get more than one, pass a structure with more profile/level pairs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_PROFILE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub profile: [MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1 {
    pub profile: MMAL_VIDEO_PROFILE_T,
    pub level: MMAL_VIDEO_LEVEL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_PROFILE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_PROFILE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_PROFILE_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_PROFILE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_PROFILE_T),
            "::",
            stringify!(profile)
        )
    );
}
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_DEFAULT: MMAL_VIDEO_RATECONTROL_T = 0;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_VARIABLE: MMAL_VIDEO_RATECONTROL_T = 1;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_CONSTANT: MMAL_VIDEO_RATECONTROL_T = 2;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_VARIABLE_SKIP_FRAMES:
    MMAL_VIDEO_RATECONTROL_T = 3;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_CONSTANT_SKIP_FRAMES:
    MMAL_VIDEO_RATECONTROL_T = 4;
pub const MMAL_VIDEO_RATECONTROL_T_MMAL_VIDEO_RATECONTROL_DUMMY: MMAL_VIDEO_RATECONTROL_T =
    2147483647;
#[doc = " Manner of video rate control"]
pub type MMAL_VIDEO_RATECONTROL_T = ::std::os::raw::c_uint;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_CYCLIC: MMAL_VIDEO_INTRA_REFRESH_T =
    0;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_ADAPTIVE: MMAL_VIDEO_INTRA_REFRESH_T =
    1;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_BOTH: MMAL_VIDEO_INTRA_REFRESH_T = 2;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_KHRONOSEXTENSIONS:
    MMAL_VIDEO_INTRA_REFRESH_T = 1862270976;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_VENDORSTARTUNUSED:
    MMAL_VIDEO_INTRA_REFRESH_T = 2130706432;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_CYCLIC_MROWS:
    MMAL_VIDEO_INTRA_REFRESH_T = 2130706433;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_PSEUDO_RAND:
    MMAL_VIDEO_INTRA_REFRESH_T = 2130706434;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_MAX: MMAL_VIDEO_INTRA_REFRESH_T =
    2130706435;
pub const MMAL_VIDEO_INTRA_REFRESH_T_MMAL_VIDEO_INTRA_REFRESH_DUMMY: MMAL_VIDEO_INTRA_REFRESH_T =
    2147483647;
#[doc = " Intra refresh modes"]
pub type MMAL_VIDEO_INTRA_REFRESH_T = ::std::os::raw::c_uint;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_DEFAULT:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 0;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_JVT:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 0;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_VOWIFI:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 1;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_CBR:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 2;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_LAST:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 3;
pub const MMAL_VIDEO_ENCODE_RC_MODEL_T_MMAL_VIDEO_ENCODER_RC_MODEL_DUMMY:
    MMAL_VIDEO_ENCODE_RC_MODEL_T = 2147483647;
pub type MMAL_VIDEO_ENCODE_RC_MODEL_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub rc_model: MMAL_VIDEO_ENCODE_RC_MODEL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rc_model) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODE_RC_MODEL_T),
            "::",
            stringify!(rc_model)
        )
    );
}
#[doc = " Video rate control setting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_RATECONTROL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub control: MMAL_VIDEO_RATECONTROL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_RATECONTROL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_RATECONTROL_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_RATECONTROL_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_RATECONTROL_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RATECONTROL_T),
            "::",
            stringify!(control)
        )
    );
}
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_4x4_INTRA:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 1;
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_8x8_INTRA:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 2;
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_16x16_INTRA:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 4;
pub const MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T_MMAL_VIDEO_ENCODER_H264_MB_INTRA_DUMMY:
    MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = 2147483647;
pub type MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub mb_mode: MMAL_VIDEO_ENCODE_H264_MB_INTRA_MODES_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_ENCODER_H264_MB_INTRA_MODES_T),
            "::",
            stringify!(mb_mode)
        )
    );
}
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_STARTCODES:
    MMAL_VIDEO_NALUNITFORMAT_T = 1;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_NALUNITPERBUFFER:
    MMAL_VIDEO_NALUNITFORMAT_T = 2;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_ONEBYTEINTERLEAVELENGTH:
    MMAL_VIDEO_NALUNITFORMAT_T = 4;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_TWOBYTEINTERLEAVELENGTH:
    MMAL_VIDEO_NALUNITFORMAT_T = 8;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_FOURBYTEINTERLEAVELENGTH:
    MMAL_VIDEO_NALUNITFORMAT_T = 16;
pub const MMAL_VIDEO_NALUNITFORMAT_T_MMAL_VIDEO_NALUNITFORMAT_DUMMY: MMAL_VIDEO_NALUNITFORMAT_T =
    2147483647;
#[doc = " NAL unit formats"]
pub type MMAL_VIDEO_NALUNITFORMAT_T = ::std::os::raw::c_uint;
#[doc = " NAL unit format setting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub format: MMAL_VIDEO_NALUNITFORMAT_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_NALUNITFORMAT_T),
            "::",
            stringify!(format)
        )
    );
}
#[doc = " H264 Only: Overrides for max macro-blocks per second, max framesize,\n and max bitrates. This overrides the default maximums for the configured level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub custom_max_mbps: u32,
    pub custom_max_fs: u32,
    pub custom_max_br_and_cpb: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_max_mbps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(custom_max_mbps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_max_fs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(custom_max_fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_max_br_and_cpb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_LEVEL_EXTENSION_T),
            "::",
            stringify!(custom_max_br_and_cpb)
        )
    );
}
#[doc = " H264 Only: Overrides for max macro-blocks per second, max framesize,\n and max bitrates. This overrides the default maximums for the configured level."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub refresh_mode: MMAL_VIDEO_INTRA_REFRESH_T,
    pub air_mbs: u32,
    pub air_ref: u32,
    pub cir_mbs: u32,
    pub pir_mbs: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(refresh_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).air_mbs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(air_mbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).air_ref) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(air_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cir_mbs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(cir_mbs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pir_mbs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTRA_REFRESH_T),
            "::",
            stringify!(pir_mbs)
        )
    );
}
#[doc = " Structure for enabling EEDE, we keep it like this for now, there could be extra fields in the future"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub enable: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_ENABLE_T),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Structure for setting lossrate for EEDE, we keep it like this for now, there could be extra fields in the future"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub loss_rate: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loss_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_EEDE_LOSSRATE_T),
            "::",
            stringify!(loss_rate)
        )
    );
}
#[doc = " Structure for setting initial DRM parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub current_time: u32,
    pub ticks_per_sec: u32,
    pub lhs: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(current_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ticks_per_sec) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(ticks_per_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lhs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_INIT_INFO_T),
            "::",
            stringify!(lhs)
        )
    );
}
#[doc = " Structure for requesting a hardware-protected memory buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Input. Zero size means internal video decoder buffer,\nmem_handle and phys_addr not returned in this case"]
    pub size_wanted: u32,
    #[doc = "< Input. 1 = protect, 0 = unprotect"]
    pub protect: u32,
    #[doc = "< Output. Handle for protected buffer"]
    pub mem_handle: u32,
    #[doc = "< Output. Physical memory address of protected buffer"]
    pub phys_addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size_wanted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(size_wanted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protect) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(protect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(mem_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phys_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_DRM_PROTECT_BUFFER_T),
            "::",
            stringify!(phys_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_RENDER_STATS_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub valid: MMAL_BOOL_T,
    pub match_: u32,
    pub period: u32,
    pub phase: u32,
    pub pixel_clock_nominal: u32,
    pub pixel_clock: u32,
    pub hvs_status: u32,
    pub dummy: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_RENDER_STATS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_RENDER_STATS_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>(),
        44usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_RENDER_STATS_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phase) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_clock_nominal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(pixel_clock_nominal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_clock) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(pixel_clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hvs_status) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(hvs_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_RENDER_STATS_T),
            "::",
            stringify!(dummy)
        )
    );
}
#[doc = "< The data is not interlaced, it is progressive scan"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceProgressive: MMAL_INTERLACETYPE_T = 0;
#[doc = "< The data is interlaced, fields sent\nseparately in temporal order, with upper field first"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldSingleUpperFirst: MMAL_INTERLACETYPE_T = 1;
#[doc = "< The data is interlaced, fields sent\nseparately in temporal order, with lower field first"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldSingleLowerFirst: MMAL_INTERLACETYPE_T = 2;
#[doc = "< The data is interlaced, two fields sent together line\ninterleaved, with the upper field temporally earlier"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldsInterleavedUpperFirst: MMAL_INTERLACETYPE_T = 3;
#[doc = "< The data is interlaced, two fields sent together line\ninterleaved, with the lower field temporally earlier"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceFieldsInterleavedLowerFirst: MMAL_INTERLACETYPE_T = 4;
#[doc = "< The stream may contain a mixture of progressive\nand interlaced frames"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceMixed: MMAL_INTERLACETYPE_T = 5;
#[doc = "< Reserved region for introducing Khronos Standard Extensions"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceKhronosExtensions: MMAL_INTERLACETYPE_T = 1862270976;
#[doc = "< Reserved region for introducing Vendor Extensions"]
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceVendorStartUnused: MMAL_INTERLACETYPE_T = 2130706432;
pub const MMAL_INTERLACETYPE_T_MMAL_InterlaceMax: MMAL_INTERLACETYPE_T = 2147483647;
pub type MMAL_INTERLACETYPE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< The interlace type of the content"]
    pub eMode: MMAL_INTERLACETYPE_T,
    #[doc = "< Whether to repeat the first field"]
    pub bRepeatFirstField: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T),
            "::",
            stringify!(eMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRepeatFirstField) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T),
            "::",
            stringify!(bRepeatFirstField)
        )
    );
}
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_WHITE: MMAL_SOURCE_PATTERN_T = 0;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_BLACK: MMAL_SOURCE_PATTERN_T = 1;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_DIAGONAL: MMAL_SOURCE_PATTERN_T = 2;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_NOISE: MMAL_SOURCE_PATTERN_T = 3;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_RANDOM: MMAL_SOURCE_PATTERN_T = 4;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_COLOUR: MMAL_SOURCE_PATTERN_T = 5;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_BLOCKS: MMAL_SOURCE_PATTERN_T = 6;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_SWIRLY: MMAL_SOURCE_PATTERN_T = 7;
pub const MMAL_SOURCE_PATTERN_T_MMAL_VIDEO_SOURCE_PATTERN_DUMMY: MMAL_SOURCE_PATTERN_T = 2147483647;
pub type MMAL_SOURCE_PATTERN_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub pattern: MMAL_SOURCE_PATTERN_T,
    #[doc = "< Colour for PATTERN_COLOUR mode"]
    pub param: u32,
    #[doc = "< Number of frames to produce. 0 for continuous."]
    pub framecount: u32,
    #[doc = "< Framerate used when determining buffer timestamps"]
    pub framerate: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framecount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(framecount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_SOURCE_PATTERN_T),
            "::",
            stringify!(framerate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_VIDEO_STALL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Whether we are stalled"]
    pub stalled: MMAL_BOOL_T,
    #[doc = "< Delay in real time (us) from last buffer to current time"]
    pub delay: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_VIDEO_STALL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_VIDEO_STALL_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_VIDEO_STALL_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_VIDEO_STALL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_VIDEO_STALL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_VIDEO_STALL_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_STALL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stalled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_STALL_T),
            "::",
            stringify!(stalled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_VIDEO_STALL_T),
            "::",
            stringify!(delay)
        )
    );
}
#[doc = "< Takes a MMAL_PARAMETER_STRING_T"]
pub const MMAL_PARAMETER_AUDIO_DESTINATION: _bindgen_ty_26 = 196608;
#[doc = "< Takes a MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T"]
pub const MMAL_PARAMETER_AUDIO_LATENCY_TARGET: _bindgen_ty_26 = 196609;
pub const MMAL_PARAMETER_AUDIO_SOURCE: _bindgen_ty_26 = 196610;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_AUDIO_PASSTHROUGH: _bindgen_ty_26 = 196611;
#[doc = " Audio-specific MMAL parameter IDs.\n @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
#[doc = " Audio latency target to maintain.\n These settings are used to adjust the clock speed in order\n to match the measured audio latency to a specified value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< whether this mode is enabled"]
    pub enable: MMAL_BOOL_T,
    #[doc = "< number of latency samples to filter on, good value: 1"]
    pub filter: u32,
    #[doc = "< target latency (microseconds)"]
    pub target: u32,
    #[doc = "< shift for storing latency values, good value: 7"]
    pub shift: u32,
    #[doc = "< multiplier for speed changes, in 24.8 format, good value: 256-512"]
    pub speed_factor: i32,
    #[doc = "< divider for comparing latency versus gradiant, good value: 300"]
    pub inter_factor: i32,
    #[doc = "< limit for speed change before nSpeedFactor is applied, good value: 100"]
    pub adj_cap: i32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed_factor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(speed_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inter_factor) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(inter_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adj_cap) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_AUDIO_LATENCY_TARGET_T),
            "::",
            stringify!(adj_cap)
        )
    );
}
#[doc = " Thresholds used when updating a clock's media-time"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_UPDATE_THRESHOLD_T {
    #[doc = " Time differences below this threshold are ignored (microseconds)"]
    pub threshold_lower: i64,
    #[doc = " Time differences above this threshold reset media-time (microseconds)"]
    pub threshold_upper: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_UPDATE_THRESHOLD_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_UPDATE_THRESHOLD_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_UPDATE_THRESHOLD_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_UPDATE_THRESHOLD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold_lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(threshold_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold_upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(threshold_upper)
        )
    );
}
#[doc = " Threshold for detecting a discontinuity in media-time"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_DISCONT_THRESHOLD_T {
    #[doc = " Threshold after which backward jumps in media-time are treated as a\n discontinuity (microseconds)"]
    pub threshold: i64,
    #[doc = " Duration in microseconds for which a discontinuity applies (wall-time)"]
    pub duration: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_DISCONT_THRESHOLD_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_DISCONT_THRESHOLD_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_DISCONT_THRESHOLD_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_DISCONT_THRESHOLD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(duration)
        )
    );
}
#[doc = " Threshold applied to client callback requests"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_REQUEST_THRESHOLD_T {
    #[doc = " Frames with a media-time difference (compared to current media-time)\n above this threshold are dropped (microseconds)"]
    pub threshold: i64,
    #[doc = " Enable/disable the request threshold"]
    pub threshold_enable: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_REQUEST_THRESHOLD_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_REQUEST_THRESHOLD_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_REQUEST_THRESHOLD_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_REQUEST_THRESHOLD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold_enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(threshold_enable)
        )
    );
}
#[doc = " Structure for passing buffer information to a clock port"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_BUFFER_INFO_T {
    pub time_stamp: i64,
    pub arrival_time: u32,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_BUFFER_INFO_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_BUFFER_INFO_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_BUFFER_INFO_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_BUFFER_INFO_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_BUFFER_INFO_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_BUFFER_INFO_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_stamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_BUFFER_INFO_T),
            "::",
            stringify!(time_stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrival_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_BUFFER_INFO_T),
            "::",
            stringify!(arrival_time)
        )
    );
}
#[doc = " Clock latency settings used by the clock component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CLOCK_LATENCY_T {
    #[doc = "< target latency (microseconds)"]
    pub target: i64,
    #[doc = "< duration of one attack period (microseconds)"]
    pub attack_period: i64,
    #[doc = "< amount by which media-time will be adjusted\nevery attack_period (microseconds)"]
    pub attack_rate: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_LATENCY_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_LATENCY_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_LATENCY_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_LATENCY_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_LATENCY_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_LATENCY_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_LATENCY_T),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attack_period) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_LATENCY_T),
            "::",
            stringify!(attack_period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attack_rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_LATENCY_T),
            "::",
            stringify!(attack_rate)
        )
    );
}
#[doc = " Clock event used to pass data between clock ports and a client."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMAL_CLOCK_EVENT_T {
    #[doc = " 4cc event id"]
    pub id: u32,
    #[doc = " 4cc event magic"]
    pub magic: u32,
    #[doc = " buffer associated with this event (can be NULL)"]
    pub buffer: *mut MMAL_BUFFER_HEADER_T,
    #[doc = " pad to 64-bit boundary"]
    pub padding0: u32,
    pub data: MMAL_CLOCK_EVENT_T__bindgen_ty_1,
    #[doc = " pad to 64-bit boundary"]
    pub padding1: u64,
}
#[doc = " additional event data (type-specific)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMAL_CLOCK_EVENT_T__bindgen_ty_1 {
    #[doc = " used either for clock reference or clock state"]
    pub enable: MMAL_BOOL_T,
    #[doc = " new clock scale"]
    pub scale: MMAL_RATIONAL_T,
    #[doc = " new media-time"]
    pub media_time: i64,
    #[doc = " media-time update threshold"]
    pub update_threshold: MMAL_CLOCK_UPDATE_THRESHOLD_T,
    #[doc = " media-time discontinuity threshold"]
    pub discont_threshold: MMAL_CLOCK_DISCONT_THRESHOLD_T,
    #[doc = " client callback request threshold"]
    pub request_threshold: MMAL_CLOCK_REQUEST_THRESHOLD_T,
    #[doc = " input/output buffer information"]
    pub buffer: MMAL_CLOCK_BUFFER_INFO_T,
    #[doc = " clock latency setting"]
    pub latency: MMAL_CLOCK_LATENCY_T,
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_EVENT_T__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_EVENT_T__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_EVENT_T__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(media_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(update_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discont_threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(discont_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_threshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(request_threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(latency)
        )
    );
}
impl ::std::fmt::Debug for MMAL_CLOCK_EVENT_T__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "MMAL_CLOCK_EVENT_T__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_MMAL_CLOCK_EVENT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CLOCK_EVENT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CLOCK_EVENT_T>(),
        56usize,
        concat!("Size of: ", stringify!(MMAL_CLOCK_EVENT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CLOCK_EVENT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CLOCK_EVENT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding0) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(padding0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CLOCK_EVENT_T),
            "::",
            stringify!(padding1)
        )
    );
}
impl ::std::fmt::Debug for MMAL_CLOCK_EVENT_T {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "MMAL_CLOCK_EVENT_T {{ buffer: {:?}, data: {:?} }}",
            self.buffer, self.data
        )
    }
}
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CLOCK_REFERENCE: _bindgen_ty_27 = 262144;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CLOCK_ACTIVE: _bindgen_ty_27 = 262145;
#[doc = "< Takes a MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_CLOCK_SCALE: _bindgen_ty_27 = 262146;
#[doc = "< Takes a MMAL_PARAMETER_INT64_T"]
pub const MMAL_PARAMETER_CLOCK_TIME: _bindgen_ty_27 = 262147;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T"]
pub const MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD: _bindgen_ty_27 = 262148;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T"]
pub const MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD: _bindgen_ty_27 = 262149;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T"]
pub const MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD: _bindgen_ty_27 = 262150;
#[doc = "< Takes a MMAL_PARAMETER_BOOLEAN_T"]
pub const MMAL_PARAMETER_CLOCK_ENABLE_BUFFER_INFO: _bindgen_ty_27 = 262151;
#[doc = "< Takes a MMAL_PARAMETER_RATIONAL_T"]
pub const MMAL_PARAMETER_CLOCK_FRAME_RATE: _bindgen_ty_27 = 262152;
#[doc = "< Takes a MMAL_PARAMETER_CLOCK_LATENCY_T"]
pub const MMAL_PARAMETER_CLOCK_LATENCY: _bindgen_ty_27 = 262153;
#[doc = " Clock-specific MMAL parameter IDs.\n @ingroup MMAL_PARAMETER_IDS"]
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
#[doc = " Media-time update thresholds"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_UPDATE_THRESHOLD_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_UPDATE_THRESHOLD_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Media-time discontinuity settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_DISCONT_THRESHOLD_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_DISCONT_THRESHOLD_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Media-time future frame drop settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_REQUEST_THRESHOLD_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_REQUEST_THRESHOLD_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Clock latency parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CLOCK_LATENCY_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    pub value: MMAL_CLOCK_LATENCY_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CLOCK_LATENCY_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CLOCK_LATENCY_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CLOCK_LATENCY_T>(),
        32usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CLOCK_LATENCY_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CLOCK_LATENCY_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic unsigned 64-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_UINT64_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_UINT64_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_UINT64_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_UINT64_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_UINT64_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_UINT64_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_UINT64_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT64_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT64_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic signed 64-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_INT64_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: i64,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_INT64_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_INT64_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_INT64_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_INT64_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_INT64_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_INT64_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT64_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT64_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic unsigned 32-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_UINT32_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_UINT32_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_UINT32_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_UINT32_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_UINT32_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_UINT32_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_UINT32_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT32_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_UINT32_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic signed 32-bit integer parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_INT32_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: i32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_INT32_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_INT32_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_INT32_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_INT32_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_INT32_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_INT32_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT32_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_INT32_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic rational parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_RATIONAL_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub value: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_RATIONAL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_RATIONAL_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_RATIONAL_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_RATIONAL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_RATIONAL_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_RATIONAL_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RATIONAL_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_RATIONAL_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Generic boolean parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BOOLEAN_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Parameter value"]
    pub enable: MMAL_BOOL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BOOLEAN_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_BOOLEAN_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BOOLEAN_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_BOOLEAN_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BOOLEAN_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_BOOLEAN_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BOOLEAN_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BOOLEAN_T),
            "::",
            stringify!(enable)
        )
    );
}
#[doc = " Generic string parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_STRING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Null-terminated string"]
    pub str_: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_STRING_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_STRING_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_STRING_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_STRING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_STRING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_STRING_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STRING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_STRING_T),
            "::",
            stringify!(str_)
        )
    );
}
#[doc = " Generic array of bytes parameter type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_BYTES_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Array of bytes"]
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_BYTES_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_BYTES_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_BYTES_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_BYTES_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_BYTES_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_BYTES_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BYTES_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_BYTES_T),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Generic two-dimensional scaling factor type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_SCALEFACTOR_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Scaling factor in X-axis"]
    pub scale_x: MMAL_FIXED_16_16_T,
    #[doc = "< Scaling factor in Y-axis"]
    pub scale_y: MMAL_FIXED_16_16_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_SCALEFACTOR_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_SCALEFACTOR_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_SCALEFACTOR_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_SCALEFACTOR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_SCALEFACTOR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_SCALEFACTOR_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SCALEFACTOR_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SCALEFACTOR_T),
            "::",
            stringify!(scale_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_SCALEFACTOR_T),
            "::",
            stringify!(scale_y)
        )
    );
}
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_NONE: MMAL_PARAM_MIRROR_T = 0;
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_VERTICAL: MMAL_PARAM_MIRROR_T = 1;
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_HORIZONTAL: MMAL_PARAM_MIRROR_T = 2;
pub const MMAL_PARAM_MIRROR_T_MMAL_PARAM_MIRROR_BOTH: MMAL_PARAM_MIRROR_T = 3;
#[doc = " Valid mirror modes"]
pub type MMAL_PARAM_MIRROR_T = ::std::os::raw::c_uint;
#[doc = " Generic mirror parameter type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_MIRROR_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Mirror mode"]
    pub value: MMAL_PARAM_MIRROR_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_MIRROR_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_MIRROR_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_MIRROR_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_MIRROR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_MIRROR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_MIRROR_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MIRROR_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_MIRROR_T),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " URI parameter type.\n The parameter may hold an arbitrary length, nul-terminated string as long\n as the size is set appropriately."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_URI_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< URI string (null-terminated)"]
    pub uri: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_URI_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_URI_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_URI_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_URI_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_URI_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_URI_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_URI_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_URI_T),
            "::",
            stringify!(uri)
        )
    );
}
#[doc = " Generic encoding parameter type.\n The parameter may hold more than one encoding by overriding the size to\n include a bigger array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_ENCODING_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Array of FourCC encodings, see \\ref MmalEncodings"]
    pub encoding: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_ENCODING_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_ENCODING_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_ENCODING_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_ENCODING_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_ENCODING_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_ENCODING_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ENCODING_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_ENCODING_T),
            "::",
            stringify!(encoding)
        )
    );
}
#[doc = " Generic frame-rate parameter type.\n Frame rates are specified as a rational number, using a pair of integers.\n Since there can be many valid pairs for the same ratio, a frame-rate may\n not contain exactly the same pairs of values when read back as it was\n when set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_FRAME_RATE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Frame-rate value"]
    pub frame_rate: MMAL_RATIONAL_T,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_FRAME_RATE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_FRAME_RATE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_FRAME_RATE_T>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_FRAME_RATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_FRAME_RATE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_FRAME_RATE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FRAME_RATE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_FRAME_RATE_T),
            "::",
            stringify!(frame_rate)
        )
    );
}
#[doc = " Generic configuration-file setup type.\n Configuration files are transferred in small chunks. The component can\n save all the chunks into a buffer, then process the entire file later.\n This parameter initialises a config file to have the given size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CONFIGFILE_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Size of complete file data"]
    pub file_size: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CONFIGFILE_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CONFIGFILE_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CONFIGFILE_T>(),
        12usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CONFIGFILE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CONFIGFILE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_PARAMETER_CONFIGFILE_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_T),
            "::",
            stringify!(file_size)
        )
    );
}
#[doc = " Generic configuration-file chunk data type.\n Once a config file has been initialised, this parameter can be used to\n write an arbitrary chunk of the file data (limited by the maximum MMAL\n message size)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PARAMETER_CONFIGFILE_CHUNK_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
    #[doc = "< Number of bytes being transferred in this chunk"]
    pub size: u32,
    #[doc = "< Offset of this chunk in the file"]
    pub offset: u32,
    #[doc = "< Chunk data"]
    pub data: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_MMAL_PARAMETER_CONFIGFILE_CHUNK_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PARAMETER_CONFIGFILE_CHUNK_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PARAMETER_CONFIGFILE_CHUNK_T>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PARAMETER_CONFIGFILE_CHUNK_T),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "< Unknown port type"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_UNKNOWN: MMAL_PORT_TYPE_T = 0;
#[doc = "< Control port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_CONTROL: MMAL_PORT_TYPE_T = 1;
#[doc = "< Input port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_INPUT: MMAL_PORT_TYPE_T = 2;
#[doc = "< Output port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_OUTPUT: MMAL_PORT_TYPE_T = 3;
#[doc = "< Clock port"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_CLOCK: MMAL_PORT_TYPE_T = 4;
#[doc = "< Dummy value to force 32bit enum"]
pub const MMAL_PORT_TYPE_T_MMAL_PORT_TYPE_INVALID: MMAL_PORT_TYPE_T = 4294967295;
#[doc = " List of port types"]
pub type MMAL_PORT_TYPE_T = ::std::os::raw::c_uint;
#[doc = " Definition of a port.\n A port is the entity that is exposed by components to receive or transmit\n buffer headers (\\ref MMAL_BUFFER_HEADER_T). A port is defined by its\n \\ref MMAL_ES_FORMAT_T.\n\n It may be possible to override the buffer requirements of a port by using\n the MMAL_PARAMETER_BUFFER_REQUIREMENTS parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PORT_T {
    #[doc = "< Private member used by the framework"]
    pub priv_: *mut MMAL_PORT_PRIVATE_T,
    #[doc = "< Port name. Used for debugging purposes (Read Only)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Type of the port (Read Only)"]
    pub type_: MMAL_PORT_TYPE_T,
    #[doc = "< Index of the port in its type list (Read Only)"]
    pub index: u16,
    #[doc = "< Index of the port in the list of all ports (Read Only)"]
    pub index_all: u16,
    #[doc = "< Indicates whether the port is enabled or not (Read Only)"]
    pub is_enabled: u32,
    #[doc = "< Format of the elementary stream"]
    pub format: *mut MMAL_ES_FORMAT_T,
    #[doc = "< Minimum number of buffers the port requires (Read Only).\nThis is set by the component."]
    pub buffer_num_min: u32,
    #[doc = "< Minimum size of buffers the port requires (Read Only).\nThis is set by the component."]
    pub buffer_size_min: u32,
    #[doc = "< Minimum alignment requirement for the buffers (Read Only).\nA value of zero means no special alignment requirements.\nThis is set by the component."]
    pub buffer_alignment_min: u32,
    #[doc = "< Number of buffers the port recommends for optimal performance (Read Only).\nA value of zero means no special recommendation.\nThis is set by the component."]
    pub buffer_num_recommended: u32,
    #[doc = "< Size of buffers the port recommends for optimal performance (Read Only).\nA value of zero means no special recommendation.\nThis is set by the component."]
    pub buffer_size_recommended: u32,
    #[doc = "< Actual number of buffers the port will use.\nThis is set by the client."]
    pub buffer_num: u32,
    #[doc = "< Actual maximum size of the buffers that will be sent\nto the port. This is set by the client."]
    pub buffer_size: u32,
    #[doc = "< Component this port belongs to (Read Only)"]
    pub component: *mut MMAL_COMPONENT_T,
    #[doc = "< Field reserved for use by the client"]
    pub userdata: *mut MMAL_PORT_USERDATA_T,
    #[doc = "< Flags describing the capabilities of a port (Read Only).\n Bitwise combination of \\ref portcapabilities \"Port capabilities\"\n values."]
    pub capabilities: u32,
}
#[test]
fn bindgen_test_layout_MMAL_PORT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_PORT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_PORT_T>(),
        96usize,
        concat!("Size of: ", stringify!(MMAL_PORT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_PORT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_PORT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index_all) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(index_all)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num_min) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_num_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_min) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_size_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_alignment_min) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_alignment_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num_recommended) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_num_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_recommended) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_size_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(component)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_PORT_T),
            "::",
            stringify!(capabilities)
        )
    );
}
extern "C" {
    #[doc = " Commit format changes on a port.\n\n @param port The port for which format changes are to be committed.\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_format_commit(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
#[doc = " Definition of the callback used by a port to send a \\ref MMAL_BUFFER_HEADER_T\n back to the user.\n\n @param port The port sending the buffer header.\n @param buffer The buffer header being sent."]
pub type MMAL_PORT_BH_CB_T = ::std::option::Option<
    unsafe extern "C" fn(port: *mut MMAL_PORT_T, buffer: *mut MMAL_BUFFER_HEADER_T),
>;
extern "C" {
    #[doc = " Enable processing on a port\n\n If this port is connected to another, the given callback must be NULL, while for a\n disconnected port, the callback must be non-NULL.\n\n If this is a connected output port and is successfully enabled:\n <ul>\n <li>The port shall be populated with a pool of buffers, allocated as required, according\n to the buffer_num and buffer_size values.\n <li>The input port to which it is connected shall be set to the same buffer\n configuration and then be enabled. Should that fail, the original port shall be\n disabled.\n </ul>\n\n @param port port to enable\n @param cb callback use by the port to send a \\ref MMAL_BUFFER_HEADER_T back\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_enable(port: *mut MMAL_PORT_T, cb: MMAL_PORT_BH_CB_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disable processing on a port\n\n Disabling a port will stop all processing on this port and return all (non-processed)\n buffer headers to the client.\n\n If this is a connected output port, the input port to which it is connected shall\n also be disabled. Any buffer pool shall be released.\n\n @param port port to disable\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_disable(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Ask a port to release all the buffer headers it currently has.\n\n Flushing a port will ask the port to send all the buffer headers it currently has\n to the client. Flushing is an asynchronous request and the flush call will\n return before all the buffer headers are returned to the client.\n It is up to the client to keep a count on the buffer headers to know when the\n flush operation has completed.\n It is also important to note that flushing will also reset the state of the port\n and any processing which was buffered by the port will be lost.\n\n \\attention Flushing a connected port behaviour TBD.\n\n @param port The port to flush.\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_flush(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Set a parameter on a port.\n\n @param port The port to which the request is sent.\n @param param The pointer to the header of the parameter to set.\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_parameter_set(
        port: *mut MMAL_PORT_T,
        param: *const MMAL_PARAMETER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Get a parameter from a port.\n The size field must be set on input to the maximum size of the parameter\n (including the header) and will be set on output to the actual size of the\n parameter retrieved.\n\n \\note If MMAL_ENOSPC is returned, the parameter is larger than the size\n given. The given parameter will have been filled up to its size and then\n the size field set to the full parameter's size. This can be used to\n resize the parameter buffer so that a second call should succeed.\n\n @param port The port to which the request is sent.\n @param param The pointer to the header of the parameter to get.\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_parameter_get(
        port: *mut MMAL_PORT_T,
        param: *mut MMAL_PARAMETER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Send a buffer header to a port.\n\n @param port The port to which the buffer header is to be sent.\n @param buffer The buffer header to send.\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_send_buffer(
        port: *mut MMAL_PORT_T,
        buffer: *mut MMAL_BUFFER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Connect an output port to an input port.\n\n When connected and enabled, buffers will automatically progress from the\n output port to the input port when they become available, and released back\n to the output port when no longer required by the input port.\n\n Ports can be given either way around, but one must be an output port and\n the other must be an input port. Neither can be connected or enabled\n already. The format of the output port will be applied to the input port\n on connection.\n\n @param port One of the ports to connect.\n @param other_port The other port to connect.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_port_connect(
        port: *mut MMAL_PORT_T,
        other_port: *mut MMAL_PORT_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disconnect a connected port.\n\n If the port is not connected, an error will be returned. Otherwise, if the\n ports are enabled, they will be disabled and any buffer pool created will be\n freed.\n\n @param port The ports to disconnect.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_port_disconnect(port: *mut MMAL_PORT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Allocate a payload buffer.\n This allows a client to allocate memory for a payload buffer based on the preferences\n of a port. This for instance will allow the port to allocate memory which can be shared\n between the host processor and videocore.\n\n See \\ref mmal_pool_create_with_allocator().\n\n @param port         Port responsible for allocating the memory.\n @param payload_size Size of the payload buffer which will be allocated.\n\n @return Pointer to the allocated memory."]
    pub fn mmal_port_payload_alloc(port: *mut MMAL_PORT_T, payload_size: u32) -> *mut u8;
}
extern "C" {
    #[doc = " Free a payload buffer.\n This allows a client to free memory allocated by a previous call to \\ref mmal_port_payload_alloc.\n\n See \\ref mmal_pool_create_with_allocator().\n\n @param port         Port responsible for allocating the memory.\n @param payload      Pointer to the memory to free."]
    pub fn mmal_port_payload_free(port: *mut MMAL_PORT_T, payload: *mut u8);
}
extern "C" {
    #[doc = " Get an empty event buffer header from a port\n\n @param port The port from which to get the event buffer header.\n @param buffer The address of a buffer header pointer, which will be set on return.\n @param event The specific event FourCC required. See the \\ref MmalEvents \"pre-defined events\".\n @return MMAL_SUCCESS on success"]
    pub fn mmal_port_event_get(
        port: *mut MMAL_PORT_T,
        buffer: *mut *mut MMAL_BUFFER_HEADER_T,
        event: u32,
    ) -> MMAL_STATUS_T::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_COMPONENT_PRIVATE_T {
    _unused: [u8; 0],
}
#[doc = " Definition of a component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_COMPONENT_T {
    #[doc = " Pointer to the private data of the module in use"]
    pub priv_: *mut MMAL_COMPONENT_PRIVATE_T,
    #[doc = " Pointer to private data of the client"]
    pub userdata: *mut MMAL_COMPONENT_USERDATA_T,
    #[doc = " Component name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Specifies whether the component is enabled or not"]
    pub is_enabled: u32,
    #[doc = " All components expose a control port.\n The control port is used by clients to set / get parameters that are global to the\n component. It is also used to receive events, which again are global to the component.\n To be able to receive events, the client needs to enable and register a callback on the\n control port."]
    pub control: *mut MMAL_PORT_T,
    #[doc = "< Number of input ports"]
    pub input_num: u32,
    #[doc = "< Array of input ports"]
    pub input: *mut *mut MMAL_PORT_T,
    #[doc = "< Number of output ports"]
    pub output_num: u32,
    #[doc = "< Array of output ports"]
    pub output: *mut *mut MMAL_PORT_T,
    #[doc = "< Number of clock ports"]
    pub clock_num: u32,
    #[doc = "< Array of clock ports"]
    pub clock: *mut *mut MMAL_PORT_T,
    #[doc = "< Total number of ports"]
    pub port_num: u32,
    #[doc = "< Array of all the ports (control/input/output/clock)"]
    pub port: *mut *mut MMAL_PORT_T,
    #[doc = " Uniquely identifies the component's instance within the MMAL\n context / process. For debugging."]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_MMAL_COMPONENT_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_COMPONENT_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_COMPONENT_T>(),
        112usize,
        concat!("Size of: ", stringify!(MMAL_COMPONENT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_COMPONENT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_COMPONENT_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_num) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(input_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_num) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(output_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_num) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(clock_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_num) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_COMPONENT_T),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    #[doc = " Create an instance of a component.\n The newly created component will expose ports to the client. All the exposed ports are\n disabled by default.\n Note that components are reference counted and creating a component automatically\n acquires a reference to it (released when \\ref mmal_component_destroy is called).\n\n @param name name of the component to create, e.g. \"video_decode\"\n @param component returned component\n @return MMAL_SUCCESS on success"]
    pub fn mmal_component_create(
        name: *const ::std::os::raw::c_char,
        component: *mut *mut MMAL_COMPONENT_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Acquire a reference on a component.\n Acquiring a reference on a component will prevent a component from being destroyed until\n the acquired reference is released (by a call to \\ref mmal_component_destroy).\n References are internally counted so all acquired references need a matching call to\n release them.\n\n @param component component to acquire"]
    pub fn mmal_component_acquire(component: *mut MMAL_COMPONENT_T);
}
extern "C" {
    #[doc = " Release a reference on a component\n Release an acquired reference on a component. Triggers the destruction of the component when\n the last reference is being released.\n \\note This is in fact an alias of \\ref mmal_component_destroy which is added to make client\n code clearer.\n\n @param component component to release\n @return MMAL_SUCCESS on success"]
    pub fn mmal_component_release(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Destroy a previously created component\n Release an acquired reference on a component. Only actually destroys the component when\n the last reference is being released.\n\n @param component component to destroy\n @return MMAL_SUCCESS on success"]
    pub fn mmal_component_destroy(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Enable processing on a component\n @param component component to enable\n @return MMAL_SUCCESS on success"]
    pub fn mmal_component_enable(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disable processing on a component\n @param component component to disable\n @return MMAL_SUCCESS on success"]
    pub fn mmal_component_disable(component: *mut MMAL_COMPONENT_T) -> MMAL_STATUS_T::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_QUEUE_T {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a queue of MMAL_BUFFER_HEADER_T\n\n @return Pointer to the newly created queue or NULL on failure."]
    pub fn mmal_queue_create() -> *mut MMAL_QUEUE_T;
}
extern "C" {
    #[doc = " Put a MMAL_BUFFER_HEADER_T into a queue\n\n @param queue  Pointer to a queue\n @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue"]
    pub fn mmal_queue_put(queue: *mut MMAL_QUEUE_T, buffer: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Put a MMAL_BUFFER_HEADER_T back at the start of a queue.\n This is used when a buffer header was removed from the queue but not\n fully processed and needs to be put back where it was originally taken.\n\n @param queue  Pointer to a queue\n @param buffer Pointer to the MMAL_BUFFER_HEADER_T to add to the queue"]
    pub fn mmal_queue_put_back(queue: *mut MMAL_QUEUE_T, buffer: *mut MMAL_BUFFER_HEADER_T);
}
extern "C" {
    #[doc = " Get a MMAL_BUFFER_HEADER_T from a queue\n\n @param queue  Pointer to a queue\n\n @return pointer to the next MMAL_BUFFER_HEADER_T or NULL if the queue is empty."]
    pub fn mmal_queue_get(queue: *mut MMAL_QUEUE_T) -> *mut MMAL_BUFFER_HEADER_T;
}
extern "C" {
    #[doc = " Wait for a MMAL_BUFFER_HEADER_T from a queue.\n This is the same as a get except that this will block until a buffer header is\n available.\n\n @param queue  Pointer to a queue\n\n @return pointer to the next MMAL_BUFFER_HEADER_T."]
    pub fn mmal_queue_wait(queue: *mut MMAL_QUEUE_T) -> *mut MMAL_BUFFER_HEADER_T;
}
extern "C" {
    #[doc = " Wait for a MMAL_BUFFER_HEADER_T from a queue, up to a given timeout.\n This is the same as a wait, except that it will abort in case of timeout.\n\n @param queue  Pointer to a queue\n @param timeout Number of milliseconds to wait before\n                returning if the semaphore can't be acquired.\n\n @return pointer to the next MMAL_BUFFER_HEADER_T."]
    pub fn mmal_queue_timedwait(
        queue: *mut MMAL_QUEUE_T,
        timeout: VCOS_UNSIGNED,
    ) -> *mut MMAL_BUFFER_HEADER_T;
}
extern "C" {
    #[doc = " Get the number of MMAL_BUFFER_HEADER_T currently in a queue.\n\n @param queue  Pointer to a queue\n\n @return length (in elements) of the queue."]
    pub fn mmal_queue_length(queue: *mut MMAL_QUEUE_T) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Destroy a queue of MMAL_BUFFER_HEADER_T.\n\n @param queue  Pointer to a queue"]
    pub fn mmal_queue_destroy(queue: *mut MMAL_QUEUE_T);
}
#[doc = " Definition of a pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_POOL_T {
    #[doc = "< Queue used by the pool"]
    pub queue: *mut MMAL_QUEUE_T,
    #[doc = "< Number of buffer headers in the pool"]
    pub headers_num: u32,
    #[doc = "< Array of buffer headers belonging to the pool"]
    pub header: *mut *mut MMAL_BUFFER_HEADER_T,
}
#[test]
fn bindgen_test_layout_MMAL_POOL_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_POOL_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_POOL_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_POOL_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_POOL_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_POOL_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_POOL_T),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers_num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_POOL_T),
            "::",
            stringify!(headers_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_POOL_T),
            "::",
            stringify!(header)
        )
    );
}
#[doc = " Allocator alloc prototype\n\n @param context The context pointer passed in on pool creation.\n @param size    The size of the allocation required, in bytes.\n @return The pointer to the newly allocated memory, or NULL on failure."]
pub type mmal_pool_allocator_alloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Allocator free prototype\n\n @param context The context pointer passed in on pool creation.\n @param mem     The pointer to the memory to be released."]
pub type mmal_pool_allocator_free_t = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, mem: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Create a pool of MMAL_BUFFER_HEADER_T.\n After allocation, all allocated buffer headers will have been added to the queue.\n\n It is valid to create a pool with no buffer headers, or with zero size payload buffers.\n The mmal_pool_resize() function can be used to increase or decrease the number of buffer\n headers, or the size of the payload buffers, after creation of the pool.\n\n The payload buffers may also be allocated independently by the client, and assigned\n to the buffer headers, but it will be the responsibility of the client to deal with\n resizing and releasing the memory. It is recommended that mmal_pool_create_with_allocator()\n is used in this case, supplying allocator function pointers that will be used as\n necessary by MMAL.\n\n @param headers      Number of buffer headers to be allocated with the pool.\n @param payload_size Size of the payload buffer that will be allocated in\n                     each of the buffer headers.\n @return Pointer to the newly created pool or NULL on failure."]
    pub fn mmal_pool_create(headers: ::std::os::raw::c_uint, payload_size: u32)
        -> *mut MMAL_POOL_T;
}
extern "C" {
    #[doc = " Create a pool of MMAL_BUFFER_HEADER_T.\n After allocation, all allocated buffer headers will have been added to the queue.\n\n It is valid to create a pool with no buffer headers, or with zero size payload buffers.\n The mmal_pool_resize() function can be used to increase or decrease the number of buffer\n headers, or the size of the payload buffers, after creation of the pool. The allocators\n passed during creation shall be used when resizing the payload buffers.\n\n @param headers      Number of buffer headers to be allocated with the pool.\n @param payload_size Size of the payload buffer that will be allocated in\n                     each of the buffer headers.\n @param allocator_context Pointer to the context of the allocator.\n @param allocator_alloc   Function pointer for the alloc call of the allocator.\n @param allocator_free    Function pointer for the free call of the allocator.\n\n @return Pointer to the newly created pool or NULL on failure."]
    pub fn mmal_pool_create_with_allocator(
        headers: ::std::os::raw::c_uint,
        payload_size: u32,
        allocator_context: *mut ::std::os::raw::c_void,
        allocator_alloc: mmal_pool_allocator_alloc_t,
        allocator_free: mmal_pool_allocator_free_t,
    ) -> *mut MMAL_POOL_T;
}
extern "C" {
    #[doc = " Destroy a pool of MMAL_BUFFER_HEADER_T.\n This will also deallocate all of the memory which was allocated when creating or\n resizing the pool.\n\n If payload buffers have been allocated independently by the client, they should be\n released prior to calling this function. If the client provided allocator functions,\n the allocator_free function shall be called for each payload buffer.\n\n @param pool  Pointer to a pool"]
    pub fn mmal_pool_destroy(pool: *mut MMAL_POOL_T);
}
extern "C" {
    #[doc = " Resize a pool of MMAL_BUFFER_HEADER_T.\n This allows modifying either the number of allocated buffers, the payload size or both at the\n same time.\n\n @param pool         Pointer to the pool\n @param headers      New number of buffer headers to be allocated in the pool.\n                     It is not valid to pass zero for the number of buffers.\n @param payload_size Size of the payload buffer that will be allocated in\n                     each of the buffer headers.\n                     If this is set to 0, all payload buffers shall be released.\n @return MMAL_SUCCESS or an error on failure."]
    pub fn mmal_pool_resize(
        pool: *mut MMAL_POOL_T,
        headers: ::std::os::raw::c_uint,
        payload_size: u32,
    ) -> MMAL_STATUS_T::Type;
}
#[doc = " Definition of the callback used by a pool to signal back to the user that a buffer header\n has been released back to the pool.\n\n @param pool       Pointer to the pool\n @param buffer     Buffer header just released\n @param userdata   User specific data passed in when setting the callback\n @return True to have the buffer header put back in the pool's queue, false if the buffer\n          header has been taken within the callback."]
pub type MMAL_POOL_BH_CB_T = ::std::option::Option<
    unsafe extern "C" fn(
        pool: *mut MMAL_POOL_T,
        buffer: *mut MMAL_BUFFER_HEADER_T,
        userdata: *mut ::std::os::raw::c_void,
    ) -> MMAL_BOOL_T,
>;
extern "C" {
    #[doc = " Set a buffer header release callback to the pool.\n Each time a buffer header is released to the pool, the callback will be triggered.\n\n @param pool     Pointer to a pool\n @param cb       Callback function\n @param userdata User specific data which will be passed with each callback"]
    pub fn mmal_pool_callback_set(
        pool: *mut MMAL_POOL_T,
        cb: MMAL_POOL_BH_CB_T,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Set a pre-release callback for all buffer headers in the pool.\n Each time a buffer header is about to be released to the pool, the callback\n will be triggered.\n\n @param pool     Pointer to the pool\n @param cb       Pre-release callback function\n @param userdata User-specific data passed back with each callback"]
    pub fn mmal_pool_pre_release_callback_set(
        pool: *mut MMAL_POOL_T,
        cb: MMAL_BH_PRE_RELEASE_CB_T,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[doc = " End-of-stream event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_EVENT_END_OF_STREAM_T {
    #[doc = "< Type of port that received the end of stream"]
    pub port_type: MMAL_PORT_TYPE_T,
    #[doc = "< Index of port that received the end of stream"]
    pub port_index: u32,
}
#[test]
fn bindgen_test_layout_MMAL_EVENT_END_OF_STREAM_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_EVENT_END_OF_STREAM_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_EVENT_END_OF_STREAM_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_EVENT_END_OF_STREAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_EVENT_END_OF_STREAM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_EVENT_END_OF_STREAM_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_END_OF_STREAM_T),
            "::",
            stringify!(port_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_END_OF_STREAM_T),
            "::",
            stringify!(port_index)
        )
    );
}
#[doc = " Format changed event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_EVENT_FORMAT_CHANGED_T {
    #[doc = "< Minimum size of buffers the port requires"]
    pub buffer_size_min: u32,
    #[doc = "< Minimum number of buffers the port requires"]
    pub buffer_num_min: u32,
    #[doc = "< Size of buffers the port recommends for optimal performance.\nA value of zero means no special recommendation."]
    pub buffer_size_recommended: u32,
    #[doc = "< Number of buffers the port recommends for optimal\nperformance. A value of zero means no special recommendation."]
    pub buffer_num_recommended: u32,
    #[doc = "< New elementary stream format"]
    pub format: *mut MMAL_ES_FORMAT_T,
}
#[test]
fn bindgen_test_layout_MMAL_EVENT_FORMAT_CHANGED_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_EVENT_FORMAT_CHANGED_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_EVENT_FORMAT_CHANGED_T>(),
        24usize,
        concat!("Size of: ", stringify!(MMAL_EVENT_FORMAT_CHANGED_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_EVENT_FORMAT_CHANGED_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_EVENT_FORMAT_CHANGED_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_size_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_num_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_size_recommended) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_size_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_num_recommended) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(buffer_num_recommended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_FORMAT_CHANGED_T),
            "::",
            stringify!(format)
        )
    );
}
#[doc = " Parameter changed event data.\n This is a variable sized event. The full parameter is included in the event\n data, not just the header. Use the \\ref MMAL_PARAMETER_HEADER_T::id field to determine how to\n cast the structure. The \\ref MMAL_PARAMETER_HEADER_T::size field can be used to check validity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_EVENT_PARAMETER_CHANGED_T {
    pub hdr: MMAL_PARAMETER_HEADER_T,
}
#[test]
fn bindgen_test_layout_MMAL_EVENT_PARAMETER_CHANGED_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_EVENT_PARAMETER_CHANGED_T> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_EVENT_PARAMETER_CHANGED_T>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_EVENT_PARAMETER_CHANGED_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_EVENT_PARAMETER_CHANGED_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_EVENT_PARAMETER_CHANGED_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_EVENT_PARAMETER_CHANGED_T),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    #[doc = " Get a pointer to the \\ref MMAL_EVENT_FORMAT_CHANGED_T structure contained in the buffer header.\n Note that the pointer will point inside the data contained in the buffer header\n so doesn't need to be freed explicitly.\n\n @param buffer buffer header containing the MMAL_EVENT_FORMAT_CHANGED event.\n @return pointer to a MMAL_EVENT_FORMAT_CHANGED_T structure."]
    pub fn mmal_event_format_changed_get(
        buffer: *mut MMAL_BUFFER_HEADER_T,
    ) -> *mut MMAL_EVENT_FORMAT_CHANGED_T;
}
#[doc = " Definition of the callback used by a connection to signal back to the client\n that a buffer header is available either in the pool or in the output queue.\n\n @param connection Pointer to the connection"]
pub type MMAL_CONNECTION_CALLBACK_T =
    ::std::option::Option<unsafe extern "C" fn(connection: *mut MMAL_CONNECTION_T)>;
#[doc = " Structure describing a connection between 2 ports (1 output and 1 input port)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_CONNECTION_T {
    #[doc = "< Field reserved for use by the client."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = "< Callback set by the client."]
    pub callback: MMAL_CONNECTION_CALLBACK_T,
    #[doc = "< Specifies whether the connection is enabled or not (Read Only)."]
    pub is_enabled: u32,
    #[doc = "< Flags passed during the create call (Read Only). A bitwise\n combination of \\ref connectionflags \"Connection flags\" values."]
    pub flags: u32,
    #[doc = "< Input port used for the connection (Read Only)."]
    pub in_: *mut MMAL_PORT_T,
    #[doc = "< Output port used for the connection (Read Only)."]
    pub out: *mut MMAL_PORT_T,
    #[doc = "< Pool of buffer headers used by the output port (Read Only)."]
    pub pool: *mut MMAL_POOL_T,
    #[doc = "< Queue for the buffer headers produced by the output port (Read Only)."]
    pub queue: *mut MMAL_QUEUE_T,
    #[doc = "< Connection name (Read Only). Used for debugging purposes."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Time in microseconds taken to setup the connection."]
    pub time_setup: i64,
    #[doc = "< Time in microseconds taken to enable the connection."]
    pub time_enable: i64,
    #[doc = "< Time in microseconds taken to disable the connection."]
    pub time_disable: i64,
}
#[test]
fn bindgen_test_layout_MMAL_CONNECTION_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_CONNECTION_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_CONNECTION_T>(),
        88usize,
        concat!("Size of: ", stringify!(MMAL_CONNECTION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_CONNECTION_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_CONNECTION_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_setup) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(time_setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_enable) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(time_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_disable) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_CONNECTION_T),
            "::",
            stringify!(time_disable)
        )
    );
}
extern "C" {
    #[doc = " Create a connection between two ports.\n The connection shall include a pool of buffer headers suitable for the current format of\n the output port. The format of the input port shall have been set to the same as that of\n the input port.\n Note that connections are reference counted and creating a connection automatically\n acquires a reference to it (released when \\ref mmal_connection_destroy is called).\n\n @param connection The address of a connection pointer that will be set to point to the created\n connection.\n @param out        The output port to use for the connection.\n @param in         The input port to use for the connection.\n @param flags      The flags specifying which type of connection should be created.\n    A bitwise combination of \\ref connectionflags \"Connection flags\" values.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_create(
        connection: *mut *mut MMAL_CONNECTION_T,
        out: *mut MMAL_PORT_T,
        in_: *mut MMAL_PORT_T,
        flags: u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Acquire a reference on a connection.\n Acquiring a reference on a connection will prevent a connection from being destroyed until\n the acquired reference is released (by a call to \\ref mmal_connection_destroy).\n References are internally counted so all acquired references need a matching call to\n release them.\n\n @param connection connection to acquire"]
    pub fn mmal_connection_acquire(connection: *mut MMAL_CONNECTION_T);
}
extern "C" {
    #[doc = " Release a reference on a connection\n Release an acquired reference on a connection. Triggers the destruction of the connection when\n the last reference is being released.\n \\note This is in fact an alias of \\ref mmal_connection_destroy which is added to make client\n code clearer.\n\n @param connection connection to release\n @return MMAL_SUCCESS on success"]
    pub fn mmal_connection_release(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Destroy a connection.\n Release an acquired reference on a connection. Only actually destroys the connection when\n the last reference is being released.\n The actual destruction of the connection will start by disabling it, if necessary.\n Any pool, queue, and so on owned by the connection shall then be destroyed.\n\n @param connection The connection to be destroyed.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_destroy(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Enable a connection.\n The format of the two ports must have been committed before calling this function,\n although note that on creation, the connection automatically copies and commits the\n output port's format to the input port.\n\n The MMAL_CONNECTION_T::callback field must have been set if the \\ref MMAL_CONNECTION_FLAG_TUNNELLING\n flag was not specified on creation. The client may also set the MMAL_CONNECTION_T::user_data\n in order to get a pointer passed, via the connection, to the callback.\n\n @param connection The connection to be enabled.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_enable(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Disable a connection.\n\n @param connection The connection to be disabled.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_disable(connection: *mut MMAL_CONNECTION_T) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Apply a format changed event to the connection.\n This function can be used when the client is processing buffer headers and receives\n a format changed event (\\ref MMAL_EVENT_FORMAT_CHANGED). The connection is\n reconfigured, changing the format of the ports, the number of buffer headers and\n the size of the payload buffers as necessary.\n\n @param connection The connection to which the event shall be applied.\n @param buffer The buffer containing a format changed event.\n @return MMAL_SUCCESS on success."]
    pub fn mmal_connection_event_format_changed(
        connection: *mut MMAL_CONNECTION_T,
        buffer: *mut MMAL_BUFFER_HEADER_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Convert a status to a statically-allocated string.\n\n @param status The MMAL status code.\n @return A C string describing the status code."]
    pub fn mmal_status_to_string(status: MMAL_STATUS_T::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert stride to pixel width for a given pixel encoding.\n\n @param encoding The pixel encoding (such as one of the \\ref MmalEncodings \"pre-defined encodings\")\n @param stride The stride in bytes.\n @return The width in pixels."]
    pub fn mmal_encoding_stride_to_width(encoding: u32, stride: u32) -> u32;
}
extern "C" {
    #[doc = " Convert pixel width to stride for a given pixel encoding\n\n @param encoding The pixel encoding (such as one of the \\ref MmalEncodings \"pre-defined encodings\")\n @param width The width in pixels.\n @return The stride in bytes."]
    pub fn mmal_encoding_width_to_stride(encoding: u32, width: u32) -> u32;
}
extern "C" {
    #[doc = " Return the 16 line high sliced version of a given pixel encoding\n\n @param encoding The pixel encoding (such as one of the \\ref MmalEncodings \"pre-defined encodings\")\n @return The sliced equivalent, or MMAL_ENCODING_UNKNOWN if not supported."]
    pub fn mmal_encoding_get_slice_variant(encoding: u32) -> u32;
}
extern "C" {
    #[doc = " Convert a port type to a string.\n\n @param type The MMAL port type.\n @return A NULL-terminated string describing the port type."]
    pub fn mmal_port_type_to_string(type_: MMAL_PORT_TYPE_T) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a parameter from a port allocating the required amount of memory\n for the parameter (i.e. for variable length parameters like URI or arrays).\n The size field will be set on output to the actual size of the\n parameter allocated and retrieved.\n\n The pointer returned must be released by a call to \\ref mmal_port_parameter_free().\n\n @param port port to send request to\n @param id parameter id\n @param size initial size hint for allocation (can be 0)\n @param status status of the parameter get operation (can be 0)\n @return pointer to the header of the parameter or NULL on failure."]
    pub fn mmal_port_parameter_alloc_get(
        port: *mut MMAL_PORT_T,
        id: u32,
        size: u32,
        status: *mut MMAL_STATUS_T::Type,
    ) -> *mut MMAL_PARAMETER_HEADER_T;
}
extern "C" {
    #[doc = " Free a parameter structure previously allocated via\n \\ref mmal_port_parameter_alloc_get().\n\n @param param pointer to header of the parameter"]
    pub fn mmal_port_parameter_free(param: *mut MMAL_PARAMETER_HEADER_T);
}
extern "C" {
    #[doc = " Copy buffer header metadata from source to destination.\n\n @param dest The destination buffer header.\n @param src  The source buffer header."]
    pub fn mmal_buffer_header_copy_header(
        dest: *mut MMAL_BUFFER_HEADER_T,
        src: *const MMAL_BUFFER_HEADER_T,
    );
}
extern "C" {
    #[doc = " Create a pool of MMAL_BUFFER_HEADER_T associated with a specific port.\n This allows a client to allocate memory for the payload buffers based on the preferences\n of a port. This for instance will allow the port to allocate memory which can be shared\n between the host processor and videocore.\n After allocation, all allocated buffer headers will have been added to the queue.\n\n It is valid to create a pool with no buffer headers, or with zero size payload buffers.\n The mmal_pool_resize() function can be used to increase or decrease the number of buffer\n headers, or the size of the payload buffers, after creation of the pool.\n\n @param port         Port responsible for creating the pool.\n @param headers      Number of buffers which will be allocated with the pool.\n @param payload_size Size of the payload buffer which will be allocated in\n                     each of the buffer headers.\n @return Pointer to the newly created pool or NULL on failure."]
    pub fn mmal_port_pool_create(
        port: *mut MMAL_PORT_T,
        headers: ::std::os::raw::c_uint,
        payload_size: u32,
    ) -> *mut MMAL_POOL_T;
}
extern "C" {
    #[doc = " Destroy a pool of MMAL_BUFFER_HEADER_T associated with a specific port.\n This will also deallocate all of the memory which was allocated when creating or\n resizing the pool.\n\n @param port  Pointer to the port responsible for creating the pool.\n @param pool  Pointer to the pool to be destroyed."]
    pub fn mmal_port_pool_destroy(port: *mut MMAL_PORT_T, pool: *mut MMAL_POOL_T);
}
extern "C" {
    #[doc = " Log the content of a \\ref MMAL_PORT_T structure.\n\n @param port  Pointer to the port to dump."]
    pub fn mmal_log_dump_port(port: *mut MMAL_PORT_T);
}
extern "C" {
    #[doc = " Log the content of a \\ref MMAL_ES_FORMAT_T structure.\n\n @param format  Pointer to the format to dump."]
    pub fn mmal_log_dump_format(format: *mut MMAL_ES_FORMAT_T);
}
extern "C" {
    #[doc = " Return the nth port.\n\n @param comp   component to query\n @param index  port index\n @param type   port type\n\n @return port or NULL if not found"]
    pub fn mmal_util_get_port(
        comp: *mut MMAL_COMPONENT_T,
        type_: MMAL_PORT_TYPE_T,
        index: ::std::os::raw::c_uint,
    ) -> *mut MMAL_PORT_T;
}
extern "C" {
    #[doc = " Convert a 4cc into a string.\n\n @param buf    Destination for result\n @param len    Size of result buffer\n @param fourcc 4cc to be converted\n @return converted string (buf)\n"]
    pub fn mmal_4cc_to_string(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        fourcc: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " On FW prior to June 2016, camera and video_splitter\n  had BGR24 and RGB24 support reversed.\n  This is now fixed, and this function will return whether the\n  FW has the fix or not.\n\n @param port   MMAL port to check (on camera or video_splitter)\n @return 0 if old firmware, 1 if new.\n"]
    pub fn mmal_util_rgb_order_fixed(port: *mut MMAL_PORT_T) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to set the value of a boolean parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  value to set the parameter to\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_boolean(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: MMAL_BOOL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a boolean parameter.\n @param port   port on which to get the parameter\n @param id     parameter id\n @param value  pointer to where the value will be returned\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_boolean(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut MMAL_BOOL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 64 bits unsigned integer parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  value to set the parameter to\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_uint64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: u64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 64 bits unsigned integer parameter.\n @param port   port on which to get the parameter\n @param id     parameter id\n @param value  pointer to where the value will be returned\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_uint64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut u64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 64 bits signed integer parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  value to set the parameter to\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_int64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: i64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 64 bits signed integer parameter.\n @param port   port on which to get the parameter\n @param id     parameter id\n @param value  pointer to where the value will be returned\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_int64(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut i64,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 32 bits unsigned integer parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  value to set the parameter to\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_uint32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 32 bits unsigned integer parameter.\n @param port   port on which to get the parameter\n @param id     parameter id\n @param value  pointer to where the value will be returned\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_uint32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a 32 bits signed integer parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  value to set the parameter to\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_int32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: i32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a 32 bits signed integer parameter.\n @param port   port on which to get the parameter\n @param id     parameter id\n @param value  pointer to where the value will be returned\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_int32(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut i32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a rational parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  value to set the parameter to\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_rational(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: MMAL_RATIONAL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to get the value of a rational parameter.\n @param port   port on which to get the parameter\n @param id     parameter id\n @param value  pointer to where the value will be returned\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_get_rational(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *mut MMAL_RATIONAL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of a string parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param value  null-terminated string value\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_string(
        port: *mut MMAL_PORT_T,
        id: u32,
        value: *const ::std::os::raw::c_char,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set the value of an array of bytes parameter.\n @param port   port on which to set the parameter\n @param id     parameter id\n @param data   pointer to the array of bytes\n @param size   size of the array of bytes\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_port_parameter_set_bytes(
        port: *mut MMAL_PORT_T,
        id: u32,
        data: *const u8,
        size: ::std::os::raw::c_uint,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Helper function to set a MMAL_PARAMETER_URI_T parameter on a port.\n @param port   port on which to set the parameter\n @param uri    URI string\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_util_port_set_uri(
        port: *mut MMAL_PORT_T,
        uri: *const ::std::os::raw::c_char,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Set the display region.\n @param port   port to configure\n @param region region\n\n @return MMAL_SUCCESS or error"]
    pub fn mmal_util_set_display_region(
        port: *mut MMAL_PORT_T,
        region: *mut MMAL_DISPLAYREGION_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Tell the camera to use the STC for timestamps rather than the clock.\n\n @param port   port to configure\n @param mode   STC mode to use\n @return MMAL_SUCCESS or error"]
    pub fn mmal_util_camera_use_stc_timestamp(
        port: *mut MMAL_PORT_T,
        mode: MMAL_CAMERA_STC_MODE_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Get the MMAL core statistics for a given port.\n\n @param port  port to query\n @param dir   port direction\n @param reset reset the stats as well\n @param stats filled in with results\n @return MMAL_SUCCESS or error"]
    pub fn mmal_util_get_core_port_stats(
        port: *mut MMAL_PORT_T,
        dir: MMAL_CORE_STATS_DIR,
        reset: MMAL_BOOL_T,
        stats: *mut MMAL_CORE_STATISTICS_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn bcm_host_init();
}
extern "C" {
    pub fn bcm_host_deinit();
}
extern "C" {
    pub fn bcm_host_get_peripheral_address() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bcm_host_get_peripheral_size() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bcm_host_get_sdram_address() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bcm_host_get_model_type() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_is_model_pi4() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_is_fkms_active() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_is_kms_active() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcm_host_get_processor_id() -> ::std::os::raw::c_int;
}
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_IDLE: MMAL_STATS_COMP_STATE_T = 0;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_CREATED: MMAL_STATS_COMP_STATE_T = 1;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_DESTROYING: MMAL_STATS_COMP_STATE_T = 2;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_DESTROYED: MMAL_STATS_COMP_STATE_T = 3;
pub const MMAL_STATS_COMP_STATE_T_MMAL_STATS_COMP_UNUSED: MMAL_STATS_COMP_STATE_T = 4294967295;
#[doc = " State of components created by the VC adaptation layer, used for\n statistics reporting."]
pub type MMAL_STATS_COMP_STATE_T = ::std::os::raw::c_uint;
#[doc = " Per-component statistics collected by the VC adaptation layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_COMP_STATS_T {
    pub comp: *mut MMAL_DRIVER_COMPONENT_T,
    pub state: MMAL_STATS_COMP_STATE_T,
    pub pid: u32,
    pub pool_mem_alloc_size: u32,
    pub name: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_MMAL_VC_COMP_STATS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_COMP_STATS_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_COMP_STATS_T>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_VC_COMP_STATS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_COMP_STATS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_VC_COMP_STATS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_mem_alloc_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(pool_mem_alloc_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_COMP_STATS_T),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " VC adaptation layer statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T {
    pub buffers: MMAL_VC_STATS_T__bindgen_ty_1,
    pub service: MMAL_VC_STATS_T_service,
    pub commands: MMAL_VC_STATS_T_commands,
    pub events: MMAL_VC_STATS_T__bindgen_ty_2,
    pub components: MMAL_VC_STATS_T__bindgen_ty_3,
    pub worker: MMAL_VC_STATS_T__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_1 {
    #[doc = "< Count of data buffers received"]
    pub rx: u32,
    #[doc = "< Count of zero-copy data buffers received"]
    pub rx_zero_copy: u32,
    #[doc = "< Empty data buffers (to be filled)"]
    pub rx_empty: u32,
    #[doc = "< Gave up partway through"]
    pub rx_fails: u32,
    #[doc = "< Count of data buffers sent"]
    pub tx: u32,
    #[doc = "< Count of zero-copy data buffers sent"]
    pub tx_zero_copy: u32,
    #[doc = "< Count of empty data buffers sent"]
    pub tx_empty: u32,
    #[doc = "< Gave up partway through"]
    pub tx_fails: u32,
    #[doc = "< Messages sent directly in the control message"]
    pub tx_short_msg: u32,
    #[doc = "< Messages received directly in the control message"]
    pub rx_short_msg: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_zero_copy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_zero_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_empty) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_empty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_fails) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_fails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_zero_copy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_zero_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_empty) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_empty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_fails) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_fails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_short_msg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(tx_short_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_short_msg) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_1),
            "::",
            stringify!(rx_short_msg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T_service {
    #[doc = "< How many services created"]
    pub created: u32,
    #[doc = "< How many destroyed"]
    pub pending_destroy: u32,
    #[doc = "< How many destroyed"]
    pub destroyed: u32,
    #[doc = "< Failures to create a service"]
    pub failures: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T_service() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T_service> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T_service>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T_service))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T_service>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T_service))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).created) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_destroy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(pending_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroyed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(destroyed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failures) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_service),
            "::",
            stringify!(failures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T_commands {
    pub bad_messages: u32,
    pub executed: u32,
    pub failed: u32,
    pub replies: u32,
    pub reply_fails: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T_commands() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T_commands> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T_commands>(),
        20usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T_commands))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T_commands>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T_commands))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bad_messages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(bad_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).executed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(executed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replies) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(replies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply_fails) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T_commands),
            "::",
            stringify!(reply_fails)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_2 {
    #[doc = "< Count of events sent"]
    pub tx: u32,
    #[doc = "< Count of events not fully sent"]
    pub tx_fails: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_2),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_fails) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_2),
            "::",
            stringify!(tx_fails)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_3 {
    pub created: u32,
    pub destroyed: u32,
    pub destroying: u32,
    pub failed: u32,
    pub list_size: u32,
    pub component_list: [MMAL_VC_COMP_STATS_T; 8usize],
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_3>(),
        344usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).created) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroyed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(destroyed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroying) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(destroying)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(list_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).component_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_3),
            "::",
            stringify!(component_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_STATS_T__bindgen_ty_4 {
    pub enqueued_messages: u32,
    pub dequeued_messages: u32,
    pub max_parameter_set_delay: u32,
    pub max_messages_waiting: u32,
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enqueued_messages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(enqueued_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dequeued_messages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(dequeued_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_parameter_set_delay) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(max_parameter_set_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_messages_waiting) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T__bindgen_ty_4),
            "::",
            stringify!(max_messages_waiting)
        )
    );
}
#[test]
fn bindgen_test_layout_MMAL_VC_STATS_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_STATS_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_STATS_T>(),
        448usize,
        concat!("Size of: ", stringify!(MMAL_VC_STATS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_STATS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MMAL_VC_STATS_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commands) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(commands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).worker) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_STATS_T),
            "::",
            stringify!(worker)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_VC_HOST_LOG_T {
    #[doc = " Simple circular buffer of plain text log messages separated by NUL"]
    pub buffer: [::std::os::raw::c_char; 16384usize],
    #[doc = " For VCDBG validation and to help detect buffer overflow"]
    pub magic: u32,
    #[doc = " Write offset into buffer"]
    pub offset: i32,
    #[doc = " Counter of host messages logged since boot"]
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_MMAL_VC_HOST_LOG_T() {
    const UNINIT: ::std::mem::MaybeUninit<MMAL_VC_HOST_LOG_T> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MMAL_VC_HOST_LOG_T>(),
        16396usize,
        concat!("Size of: ", stringify!(MMAL_VC_HOST_LOG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MMAL_VC_HOST_LOG_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MMAL_VC_HOST_LOG_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16388usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(MMAL_VC_HOST_LOG_T),
            "::",
            stringify!(count)
        )
    );
}
pub const MMAL_STATS_RESULT_T_MMAL_STATS_FOUND: MMAL_STATS_RESULT_T = 0;
pub const MMAL_STATS_RESULT_T_MMAL_STATS_COMPONENT_NOT_FOUND: MMAL_STATS_RESULT_T = 1;
pub const MMAL_STATS_RESULT_T_MMAL_STATS_PORT_NOT_FOUND: MMAL_STATS_RESULT_T = 2;
pub const MMAL_STATS_RESULT_T_MMAL_STATS_INVALID: MMAL_STATS_RESULT_T = 2147483647;
#[doc = " Status from querying MMAL core statistics."]
pub type MMAL_STATS_RESULT_T = ::std::os::raw::c_uint;
extern "C" {
    pub fn mmal_vc_init() -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_init_fd(dev_vchiq_fd: ::std::os::raw::c_int) -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_deinit();
}
extern "C" {
    pub fn mmal_vc_use() -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_release() -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_get_version(
        major: *mut u32,
        minor: *mut u32,
        minimum: *mut u32,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    pub fn mmal_vc_get_stats(
        stats: *mut MMAL_VC_STATS_T,
        reset: ::std::os::raw::c_int,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Return the MMAL core statistics for a given component/port.\n\n @param stats         Updated with given port statistics\n @param result        Whether the port/component was found\n @param name          Filled in with the name of the port\n @param namelen       Length of name\n @param component     Which component (indexed from zero)\n @param port_type     Which type of port\n @param port          Which port (index from zero)\n @param reset         Reset the stats."]
    pub fn mmal_vc_get_core_stats(
        stats: *mut MMAL_CORE_STATISTICS_T,
        result: *mut MMAL_STATS_RESULT_T,
        name: *mut ::std::os::raw::c_char,
        namelen: usize,
        type_: MMAL_PORT_TYPE_T,
        component: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_uint,
        dir: MMAL_CORE_STATS_DIR,
        reset: MMAL_BOOL_T,
    ) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Stores an arbitrary text message in a circular buffer inside the MMAL VC server.\n The purpose of this message is to log high level events from the host in order\n to diagnose problems that require multiple actions to reproduce. e.g. taking\n multiple pictures with different settings.\n\n @param   msg  The message text.\n @return  MMAL_SUCCESS if the message was logged or MMAL_ENOSYS if the API\n          if not supported."]
    pub fn mmal_vc_host_log(msg: *const ::std::os::raw::c_char) -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Consumes memory in the relocatable heap.\n\n The existing reserved memory is freed first then the new chunk is allocated.\n If zero is specified for the size then the previously reserved memory\n is freed and no allocation occurs.\n\n At startup no memory is reserved.\n\n @param size    Size of memory to consume in bytes.\n @param handle  Set to the mem handle for the reserved memory or zero\n                if no memory was allocated.\n @return        MMAL_SUCCESS if memory was reserved (or size zero requested),\n                MMAL_ENOSPC if the allocation failed or MMAL_ENOSYS if the\n                API is not supported e.g in release mode VC images.\n @internal"]
    pub fn mmal_vc_consume_mem(size: usize, handle: *mut u32) -> MMAL_STATUS_T::Type;
}
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_NONE: MMAL_VC_COMPACT_MODE_T = 0;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_NORMAL: MMAL_VC_COMPACT_MODE_T = 1;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_DISCARD: MMAL_VC_COMPACT_MODE_T = 2;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_AGGRESSIVE: MMAL_VC_COMPACT_MODE_T = 4;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_SHUFFLE: MMAL_VC_COMPACT_MODE_T = 128;
pub const MMAL_VC_COMPACT_MODE_T_MMAL_VC_COMPACT_ALL: MMAL_VC_COMPACT_MODE_T = 7;
pub type MMAL_VC_COMPACT_MODE_T = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Trigger relocatable heap compaction.\n @internal"]
    pub fn mmal_vc_compact(mode: MMAL_VC_COMPACT_MODE_T, duration: *mut u32)
        -> MMAL_STATUS_T::Type;
}
extern "C" {
    #[doc = " Trigger LMK action from VC, for diagnostics.\n @internal"]
    pub fn mmal_vc_lmk(alloc_size: u32) -> MMAL_STATUS_T::Type;
}
#[doc = "< There are 'n' named semaphores per 1 actual semaphore"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_IMPL_T {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[doc = "< Data private to the framework"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_BUFFER_HEADER_PRIVATE_T {
    pub _address: u8,
}
#[doc = "< Private member used by the framework"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PORT_PRIVATE_T {
    pub _address: u8,
}
#[doc = "< Field reserved for use by the client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_PORT_USERDATA_T {
    pub _address: u8,
}
#[doc = " Pointer to private data of the client"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_COMPONENT_USERDATA_T {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMAL_DRIVER_COMPONENT_T {
    pub _address: u8,
}
